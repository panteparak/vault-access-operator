{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Vault Access Operator","text":"<p>A Kubernetes operator for managing HashiCorp Vault access policies and Kubernetes authentication roles declaratively through Custom Resource Definitions (CRDs).</p>"},{"location":"#overview","title":"Overview","text":"<p>The Vault Access Operator enables platform teams to manage Vault policies and Kubernetes authentication roles using native Kubernetes resources. It provides a GitOps-friendly approach to Vault access management, allowing teams to version control their Vault configurations alongside their application deployments.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#access-management","title":"Access Management","text":"<ul> <li>Declarative Vault Policy Management - Define Vault policies as Kubernetes resources</li> <li>Kubernetes Auth Role Management - Configure Vault Kubernetes authentication roles through CRDs</li> <li>Namespace Boundary Enforcement - Automatically restrict namespaced policies to their namespace scope</li> <li>Variable Substitution - Use <code>{{namespace}}</code> and <code>{{name}}</code> variables in policy paths</li> </ul>"},{"location":"#authentication","title":"Authentication","text":"<ul> <li>8 Authentication Methods - Support for Kubernetes, JWT, OIDC, AWS IAM, GCP IAM, AppRole, Token, and Bootstrap</li> <li>Token Renewal Strategies - Choose between renew or re-authenticate strategies</li> <li>Automatic Token Management - Proactive token renewal before expiration</li> </ul>"},{"location":"#operations","title":"Operations","text":"<ul> <li>Drift Detection - Detect and optionally correct configuration drift between K8s and Vault</li> <li>Resource Discovery - Find unmanaged Vault resources for adoption</li> <li>Conflict Detection and Handling - Choose between fail-fast or adopt strategies for existing resources</li> <li>Deletion Policies - Control whether Vault resources are retained or deleted when K8s resources are removed</li> </ul>"},{"location":"#reliability","title":"Reliability","text":"<ul> <li>Exponential Backoff Retry - Intelligent retry with jitter for transient failures</li> <li>Health Monitoring - Continuous health checks with automatic recovery</li> <li>Admission Webhooks - Validate resources before creation with detailed error messages</li> </ul>"},{"location":"#quick-installation","title":"Quick Installation","text":"Helm (Recommended)kubectl <pre><code>helm install vault-access-operator \\\n  oci://ghcr.io/panteparak/vault-access-operator/charts/vault-access-operator \\\n  --namespace vault-access-operator-system \\\n  --create-namespace\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/panteparak/vault-access-operator/main/dist/install.yaml\n</code></pre> <p>For detailed installation instructions, see the Getting Started guide.</p>"},{"location":"#custom-resource-definitions","title":"Custom Resource Definitions","text":"<p>The operator provides five CRDs for managing Vault access:</p> CRD Scope Description VaultConnection Cluster Establishes connection to Vault server VaultClusterPolicy Cluster Manages cluster-wide Vault policies VaultPolicy Namespaced Manages namespace-scoped Vault policies VaultClusterRole Cluster Manages cluster-wide Kubernetes auth roles VaultRole Namespaced Manages namespace-scoped Kubernetes auth roles"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster (v1.25+)</li> <li>HashiCorp Vault server</li> <li>cert-manager (for webhook certificates, optional)</li> <li>kubectl configured to access your cluster</li> </ul>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Getting Started - Installation and quick start guide</li> <li>Examples - CRD usage examples</li> </ul>"},{"location":"#concepts","title":"Concepts","text":"<ul> <li>Concepts Overview - Core design principles and architecture</li> <li>Architecture - Internal structure and reconciliation flow</li> <li>Drift Detection - Detecting and correcting configuration drift</li> <li>Discovery - Finding unmanaged Vault resources</li> </ul>"},{"location":"#authentication-methods","title":"Authentication Methods","text":"<ul> <li>Authentication Overview - Comparison and decision guide</li> <li>Kubernetes Auth - Standard K8s authentication</li> <li>AWS IAM - EKS with IRSA</li> <li>GCP IAM - GKE with Workload Identity</li> <li>OIDC - Workload identity federation</li> <li>JWT - External JWT providers</li> <li>AppRole - CI/CD pipelines</li> <li>Bootstrap - Initial Vault setup</li> <li>Token - Development only</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Configuration - Helm chart configuration options</li> <li>API Reference - Detailed CRD documentation</li> <li>Webhooks - Admission webhook documentation</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> </ul>"},{"location":"#license","title":"License","text":"<p>Copyright 2024-2026 Vault Access Operator Contributors.</p> <p>Licensed under the Apache License, Version 2.0.</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page documents all Custom Resource Definitions (CRDs) provided by the Vault Access Operator.</p>"},{"location":"api-reference/#overview","title":"Overview","text":"CRD Scope Description VaultConnection Cluster Establishes connection to Vault server VaultPolicy Namespaced Manages namespace-scoped Vault policies VaultClusterPolicy Cluster Manages cluster-wide Vault policies VaultRole Namespaced Manages namespace-scoped Kubernetes auth roles VaultClusterRole Cluster Manages cluster-wide Kubernetes auth roles <p>All CRDs belong to the <code>vault.platform.io</code> API group with version <code>v1alpha1</code>.</p>"},{"location":"api-reference/#common-concepts","title":"Common Concepts","text":""},{"location":"api-reference/#conflict-policies","title":"Conflict Policies","text":"<p>When creating resources that may already exist in Vault:</p> Policy Behavior <code>Fail</code> Fail if a resource with the same name exists (default) <code>Adopt</code> Adopt and manage the existing resource"},{"location":"api-reference/#deletion-policies","title":"Deletion Policies","text":"<p>Control what happens when a Kubernetes resource is deleted:</p> Policy Behavior <code>Delete</code> Delete the resource from Vault (default) <code>Retain</code> Keep the resource in Vault"},{"location":"api-reference/#variable-substitution","title":"Variable Substitution","text":"<p>Policies support variable substitution in paths:</p> Variable Substituted With <code>{{namespace}}</code> The Kubernetes namespace of the resource <code>{{name}}</code> The name of the Kubernetes resource"},{"location":"api-reference/#resource-phases","title":"Resource Phases","text":"<p>All resources report their current phase in status:</p> Phase Description <code>Pending</code> Resource is being processed <code>Active</code> Resource is successfully synced to Vault <code>Failed</code> Resource sync failed <code>Conflict</code> Conflict with existing Vault resource"},{"location":"api-reference/#vaultconnection","title":"VaultConnection","text":"<p>Establishes and manages a connection to a HashiCorp Vault server.</p> <ul> <li>Scope: Cluster</li> <li>Short Name: N/A</li> </ul>"},{"location":"api-reference/#example","title":"Example","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    kubernetes:\n      role: vault-access-operator\n  healthCheckInterval: 30s\n</code></pre>"},{"location":"api-reference/#spec-fields","title":"Spec Fields","text":"Field Type Required Default Description <code>address</code> string Yes - Vault server address <code>auth</code> AuthConfig Yes - Authentication configuration <code>tls</code> TLSConfig No - TLS configuration <code>healthCheckInterval</code> duration No <code>30s</code> Health check interval"},{"location":"api-reference/#authconfig","title":"AuthConfig","text":"Field Type Description <code>kubernetes</code> KubernetesAuth Kubernetes service account authentication <code>token</code> TokenAuth Static token authentication <code>appRole</code> AppRoleAuth AppRole authentication <code>bootstrap</code> BootstrapAuth One-time bootstrap authentication"},{"location":"api-reference/#kubernetesauth","title":"KubernetesAuth","text":"Field Type Default Description <code>role</code> string Required Vault role to authenticate as <code>authPath</code> string <code>kubernetes</code> Mount path of Kubernetes auth method <code>tokenDuration</code> duration <code>1h</code> Requested SA token lifetime (uses TokenRequest API) <code>tokenReviewerRotation</code> bool <code>true</code> Enable automatic token_reviewer_jwt rotation"},{"location":"api-reference/#tokenauth","title":"TokenAuth","text":"Field Type Default Description <code>secretRef</code> SecretKeySelector Required Reference to secret containing Vault token"},{"location":"api-reference/#approleauth","title":"AppRoleAuth","text":"Field Type Default Description <code>roleId</code> string Required AppRole role ID <code>secretIdRef</code> SecretKeySelector Required Reference to secret containing AppRole secret ID <code>mountPath</code> string <code>approle</code> Mount path of AppRole auth method"},{"location":"api-reference/#jwtauth","title":"JWTAuth","text":"<p>Configures JWT authentication with external identity providers. Use this for generic JWT-based authentication from any identity provider (Cognito, Auth0, Okta, etc.).</p> Field Type Default Description <code>role</code> string Required Vault role configured for JWT auth <code>authPath</code> string <code>jwt</code> Auth method mount path <code>jwtSecretRef</code> SecretKeySelector - Reference to secret containing JWT. If not provided, uses TokenRequest API <code>audiences</code> []string <code>[\"vault\"]</code> Token audiences (maps to <code>aud</code> claim) <code>tokenDuration</code> duration <code>1h</code> Requested token lifetime <code>expectedIssuer</code> string - Expected <code>iss</code> claim value (for pre-flight validation) <code>expectedAudience</code> string - Expected <code>aud</code> claim value (for pre-flight validation) <code>userClaim</code> string <code>sub</code> Claim to use for Vault entity alias <code>groupsClaim</code> string - Claim containing group membership <code>claimsToPass</code> []string - Claims to include in auth response metadata"},{"location":"api-reference/#oidcauth","title":"OIDCAuth","text":"<p>Configures OIDC authentication for workload identity federation. Supports EKS OIDC, Azure AD, GKE, and any OpenID Connect provider.</p> Field Type Default Description <code>role</code> string Required Vault role configured for OIDC auth <code>authPath</code> string <code>oidc</code> Auth method mount path <code>providerURL</code> string - OIDC provider URL (issuer). Examples: <code>https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLE</code> <code>useServiceAccountToken</code> bool <code>true</code> Use K8s service account token for OIDC auth <code>audiences</code> []string <code>[providerURL]</code> Token audiences <code>tokenDuration</code> duration <code>1h</code> Requested token lifetime <code>jwtSecretRef</code> SecretKeySelector - Pre-obtained JWT (alternative to SA token) <code>userClaim</code> string - Claim to use for Vault entity alias <code>groupsClaim</code> string - Claim containing group membership <code>scopes</code> []string - OIDC scopes (for browser-based flows)"},{"location":"api-reference/#awsauth","title":"AWSAuth","text":"<p>Configures AWS IAM authentication for EKS workloads using IRSA (IAM Roles for Service Accounts) or EC2 instance profiles.</p> Field Type Default Description <code>role</code> string Required Vault role configured for AWS auth <code>authPath</code> string <code>aws</code> Auth method mount path <code>authType</code> string <code>iam</code> Auth type: <code>iam</code> (recommended) or <code>ec2</code> <code>region</code> string auto-detect AWS region <code>stsEndpoint</code> string - Custom STS endpoint (for private endpoints) <code>iamServerIdHeaderValue</code> string - X-Vault-AWS-IAM-Server-ID header value"},{"location":"api-reference/#gcpauth","title":"GCPAuth","text":"<p>Configures GCP IAM authentication for GKE workloads using Workload Identity or service account keys.</p> Field Type Default Description <code>role</code> string Required Vault role configured for GCP auth <code>authPath</code> string <code>gcp</code> Auth method mount path <code>authType</code> string <code>iam</code> Auth type: <code>iam</code> (recommended) or <code>gce</code> <code>serviceAccountEmail</code> string auto-detect GCP service account email <code>credentialsSecretRef</code> SecretKeySelector - GCP credentials JSON (for non-Workload Identity)"},{"location":"api-reference/#bootstrapauth","title":"BootstrapAuth","text":"Field Type Default Description <code>secretRef</code> SecretKeySelector Required Reference to secret containing bootstrap token <code>autoRevoke</code> bool <code>true</code> Revoke bootstrap token after successful setup"},{"location":"api-reference/#tlsconfig","title":"TLSConfig","text":"Field Type Default Description <code>skipVerify</code> bool <code>false</code> Skip TLS verification (not recommended) <code>caSecretRef</code> SecretKeySelector - Reference to CA certificate secret"},{"location":"api-reference/#connectiondefaults","title":"ConnectionDefaults","text":"<p>Optional default paths for Vault operations.</p> Field Type Default Description <code>secretEnginePath</code> string - Default path for secret engines <code>transitPath</code> string - Default path for transit engine <code>authPath</code> string <code>auth/kubernetes</code> Default path for auth methods"},{"location":"api-reference/#status-fields","title":"Status Fields","text":"Field Type Description <code>phase</code> string <code>Pending</code>, <code>Active</code>, <code>Error</code> <code>vaultVersion</code> string Version of connected Vault server <code>lastHeartbeat</code> time Time of last successful health check <code>authStatus</code> AuthStatus Authentication-related status information <code>conditions</code> []Condition Detailed state conditions <code>message</code> string Additional status information"},{"location":"api-reference/#authstatus","title":"AuthStatus","text":"<p>Authentication-specific status information.</p> Field Type Description <code>bootstrapComplete</code> bool Whether bootstrap has completed <code>bootstrapCompletedAt</code> time When bootstrap completed <code>authMethod</code> string Currently active auth method <code>tokenExpiration</code> time Current Vault token expiration <code>tokenLastRenewed</code> time When token was last renewed <code>tokenRenewalCount</code> int Number of token renewals <code>tokenReviewerExpiration</code> time When token_reviewer_jwt expires (K8s auth only) <code>tokenReviewerLastRefresh</code> time When token_reviewer_jwt was last refreshed"},{"location":"api-reference/#kubectl-output","title":"kubectl Output","text":"<pre><code>$ kubectl get vaultconnection\nNAME            ADDRESS                          PHASE    VERSION   AGE\nvault-primary   https://vault.example.com:8200   Active   1.15.0    5d\n</code></pre>"},{"location":"api-reference/#vaultpolicy","title":"VaultPolicy","text":"<p>Manages namespace-scoped Vault policies.</p> <ul> <li>Scope: Namespaced</li> <li>Short Name: <code>vp</code></li> <li>Vault Name Format: <code>{namespace}-{name}</code></li> </ul>"},{"location":"api-reference/#example_1","title":"Example","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: app-secrets\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [read, list]\n      description: \"Read application secrets\"\n</code></pre>"},{"location":"api-reference/#spec-fields_1","title":"Spec Fields","text":"Field Type Required Default Description <code>connectionRef</code> string Yes - Name of VaultConnection to use <code>rules</code> []PolicyRule Yes - List of policy rules (min 1) <code>conflictPolicy</code> string No <code>Fail</code> <code>Fail</code> or <code>Adopt</code> <code>deletionPolicy</code> string No <code>Delete</code> <code>Delete</code> or <code>Retain</code> <code>enforceNamespaceBoundary</code> bool No <code>false</code> Require <code>{{namespace}}</code> in all paths"},{"location":"api-reference/#policyrule","title":"PolicyRule","text":"Field Type Description <code>path</code> string Vault path (supports <code>{{namespace}}</code>, <code>{{name}}</code>) <code>capabilities</code> []string <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>list</code>, <code>sudo</code>, <code>deny</code> <code>description</code> string Optional description"},{"location":"api-reference/#status-fields_1","title":"Status Fields","text":"Field Type Description <code>phase</code> string <code>Pending</code>, <code>Syncing</code>, <code>Active</code>, <code>Conflict</code>, <code>Error</code> <code>vaultName</code> string Name of policy in Vault <code>rulesCount</code> int Number of rules <code>lastSyncedAt</code> time Time of last successful sync"},{"location":"api-reference/#kubectl-output_1","title":"kubectl Output","text":"<pre><code>$ kubectl get vaultpolicy -n my-app\nNAME          VAULT NAME          PHASE    RULES   AGE\napp-secrets   my-app-app-secrets  Active   2       1h\n</code></pre>"},{"location":"api-reference/#vaultclusterpolicy","title":"VaultClusterPolicy","text":"<p>Manages cluster-wide Vault policies.</p> <ul> <li>Scope: Cluster</li> <li>Short Name: <code>vcp</code></li> <li>Vault Name Format: <code>{name}</code> (same as resource name)</li> </ul>"},{"location":"api-reference/#example_2","title":"Example","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: shared-secrets-reader\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/shared/*\"\n      capabilities: [read, list]\n      description: \"Read shared configuration\"\n</code></pre>"},{"location":"api-reference/#spec-fields_2","title":"Spec Fields","text":"Field Type Required Default Description <code>connectionRef</code> string Yes - Name of VaultConnection to use <code>rules</code> []PolicyRule Yes - List of policy rules (min 1) <code>conflictPolicy</code> string No <code>Fail</code> <code>Fail</code> or <code>Adopt</code> <code>deletionPolicy</code> string No <code>Delete</code> <code>Delete</code> or <code>Retain</code>"},{"location":"api-reference/#comparison-with-vaultpolicy","title":"Comparison with VaultPolicy","text":"Feature VaultPolicy VaultClusterPolicy Scope Namespaced Cluster Vault name <code>{namespace}-{name}</code> <code>{name}</code> Variables <code>{{namespace}}</code>, <code>{{name}}</code> <code>{{name}}</code> only Namespace boundary Optional N/A"},{"location":"api-reference/#kubectl-output_2","title":"kubectl Output","text":"<pre><code>$ kubectl get vaultclusterpolicy\nNAME                    VAULT NAME              PHASE    RULES   AGE\nshared-secrets-reader   shared-secrets-reader   Active   2       5d\n</code></pre>"},{"location":"api-reference/#vaultrole","title":"VaultRole","text":"<p>Manages namespace-scoped Kubernetes authentication roles in Vault.</p> <ul> <li>Scope: Namespaced</li> <li>Short Name: <code>vr</code></li> <li>Vault Role Name Format: <code>{namespace}-{name}</code></li> </ul>"},{"location":"api-reference/#example_3","title":"Example","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: app-role\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - default\n  policies:\n    - kind: VaultPolicy\n      name: app-secrets\n  tokenTTL: 1h\n</code></pre>"},{"location":"api-reference/#spec-fields_3","title":"Spec Fields","text":"Field Type Required Default Description <code>connectionRef</code> string Yes - Name of VaultConnection to use <code>serviceAccounts</code> []string Yes - Service account names (same namespace) <code>policies</code> []PolicyReference Yes - Policies to attach (min 1) <code>authPath</code> string No From connection Kubernetes auth mount path <code>conflictPolicy</code> string No <code>Fail</code> <code>Fail</code> or <code>Adopt</code> <code>deletionPolicy</code> string No <code>Delete</code> <code>Delete</code> or <code>Retain</code> <code>tokenTTL</code> duration No Vault default Default token TTL <code>tokenMaxTTL</code> duration No Vault default Maximum token TTL"},{"location":"api-reference/#policyreference","title":"PolicyReference","text":"Field Type Description <code>kind</code> string <code>VaultPolicy</code> or <code>VaultClusterPolicy</code> <code>name</code> string Name of the policy resource <code>namespace</code> string Namespace (only for VaultPolicy, defaults to same)"},{"location":"api-reference/#status-fields_2","title":"Status Fields","text":"Field Type Description <code>phase</code> string <code>Pending</code>, <code>Syncing</code>, <code>Active</code>, <code>Conflict</code>, <code>Error</code> <code>vaultRoleName</code> string Name of role in Vault <code>boundServiceAccounts</code> []string Resolved service account names <code>resolvedPolicies</code> []string Resolved Vault policy names"},{"location":"api-reference/#kubectl-output_3","title":"kubectl Output","text":"<pre><code>$ kubectl get vaultrole -n my-app\nNAME       VAULT ROLE        PHASE    POLICIES                               AGE\napp-role   my-app-app-role   Active   [\"my-app-app-secrets\",\"shared-reader\"] 1h\n</code></pre>"},{"location":"api-reference/#vaultclusterrole","title":"VaultClusterRole","text":"<p>Manages cluster-wide Kubernetes authentication roles in Vault.</p> <ul> <li>Scope: Cluster</li> <li>Short Name: <code>vcr</code></li> <li>Vault Role Name Format: <code>{name}</code> (same as resource name)</li> </ul>"},{"location":"api-reference/#example_4","title":"Example","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterRole\nmetadata:\n  name: platform-services\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - name: platform-controller\n      namespace: platform-system\n  policies:\n    - kind: VaultClusterPolicy\n      name: shared-secrets-reader\n  tokenTTL: 1h\n</code></pre>"},{"location":"api-reference/#spec-fields_4","title":"Spec Fields","text":"Field Type Required Default Description <code>connectionRef</code> string Yes - Name of VaultConnection to use <code>serviceAccounts</code> []ServiceAccountRef Yes - Service accounts with namespace <code>policies</code> []PolicyReference Yes - Policies to attach (min 1) <code>authPath</code> string No From connection Kubernetes auth mount path <code>conflictPolicy</code> string No <code>Fail</code> <code>Fail</code> or <code>Adopt</code> <code>deletionPolicy</code> string No <code>Delete</code> <code>Delete</code> or <code>Retain</code> <code>tokenTTL</code> duration No Vault default Default token TTL <code>tokenMaxTTL</code> duration No Vault default Maximum token TTL"},{"location":"api-reference/#serviceaccountref","title":"ServiceAccountRef","text":"Field Type Description <code>name</code> string Name of the service account <code>namespace</code> string Namespace of the service account"},{"location":"api-reference/#comparison-with-vaultrole","title":"Comparison with VaultRole","text":"Feature VaultRole VaultClusterRole Scope Namespaced Cluster Vault role name <code>{namespace}-{name}</code> <code>{name}</code> Service accounts Same namespace only Any namespace"},{"location":"api-reference/#kubectl-output_4","title":"kubectl Output","text":"<pre><code>$ kubectl get vaultclusterrole\nNAME                VAULT ROLE          PHASE    POLICIES                    AGE\nplatform-services   platform-services   Active   [\"shared-secrets-reader\"]   5d\n</code></pre>"},{"location":"api-reference/#secretkeyselector","title":"SecretKeySelector","text":"<p>Reference to a key in a Kubernetes Secret (used in multiple CRDs):</p> Field Type Description <code>name</code> string Name of the Secret <code>namespace</code> string Namespace (defaults to resource namespace) <code>key</code> string Key within the Secret"},{"location":"api-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation guide</li> <li>Examples - CRD usage examples</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>This page documents all available Helm chart configuration options.</p>"},{"location":"configuration/#installation","title":"Installation","text":"<pre><code>helm install vault-access-operator \\\n  oci://ghcr.io/panteparak/vault-access-operator/charts/vault-access-operator \\\n  --namespace vault-access-operator-system \\\n  --create-namespace \\\n  -f values.yaml\n</code></pre>"},{"location":"configuration/#values-reference","title":"Values Reference","text":""},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":"Parameter Description Default <code>replicaCount</code> Number of operator replicas <code>1</code> <code>nameOverride</code> Override the chart name <code>\"\"</code> <code>fullnameOverride</code> Override the full release name <code>\"\"</code>"},{"location":"configuration/#image-configuration","title":"Image Configuration","text":"Parameter Description Default <code>image.repository</code> Image repository <code>ghcr.io/panteparak/vault-access-operator</code> <code>image.pullPolicy</code> Image pull policy <code>IfNotPresent</code> <code>image.tag</code> Image tag (defaults to chart appVersion) <code>\"\"</code> <code>imagePullSecrets</code> Image pull secrets for private registries <code>[]</code>"},{"location":"configuration/#service-account","title":"Service Account","text":"Parameter Description Default <code>serviceAccount.create</code> Create a service account <code>true</code> <code>serviceAccount.annotations</code> Annotations for the service account <code>{}</code> <code>serviceAccount.name</code> Service account name <code>\"\"</code>"},{"location":"configuration/#resources","title":"Resources","text":"Parameter Description Default <code>resources.limits.cpu</code> CPU limit <code>500m</code> <code>resources.limits.memory</code> Memory limit <code>256Mi</code> <code>resources.requests.cpu</code> CPU request <code>100m</code> <code>resources.requests.memory</code> Memory request <code>128Mi</code>"},{"location":"configuration/#security-context","title":"Security Context","text":"Parameter Description Default <code>podSecurityContext.runAsNonRoot</code> Run as non-root user <code>true</code> <code>podSecurityContext.seccompProfile.type</code> Seccomp profile <code>RuntimeDefault</code> <code>securityContext.allowPrivilegeEscalation</code> Allow privilege escalation <code>false</code> <code>securityContext.capabilities.drop</code> Dropped capabilities <code>[\"ALL\"]</code> <code>securityContext.readOnlyRootFilesystem</code> Read-only root filesystem <code>true</code>"},{"location":"configuration/#webhooks","title":"Webhooks","text":"Parameter Description Default <code>webhook.enabled</code> Enable admission webhooks <code>true</code> <code>webhook.port</code> Webhook server port <code>9443</code> <code>webhook.failurePolicy</code> Webhook failure policy <code>Fail</code> <code>webhook.timeoutSeconds</code> Webhook timeout <code>10</code>"},{"location":"configuration/#webhook-certificates","title":"Webhook Certificates","text":"Parameter Description Default <code>webhook.certManager.enabled</code> Use cert-manager for certificates <code>true</code> <code>webhook.certManager.issuerName</code> Cert-manager issuer name <code>\"\"</code> <code>webhook.certManager.duration</code> Certificate duration <code>8760h</code> <code>webhook.selfSigned.enabled</code> Generate self-signed certificates <code>false</code> <code>webhook.selfSigned.validityDays</code> Certificate validity (days) <code>365</code>"},{"location":"configuration/#metrics","title":"Metrics","text":"Parameter Description Default <code>metrics.enabled</code> Enable metrics endpoint <code>true</code> <code>metrics.secure</code> Use HTTPS for metrics <code>true</code> <code>metrics.port</code> Metrics port <code>8443</code>"},{"location":"configuration/#servicemonitor-prometheus","title":"ServiceMonitor (Prometheus)","text":"Parameter Description Default <code>serviceMonitor.enabled</code> Create ServiceMonitor resource <code>false</code> <code>serviceMonitor.namespace</code> Namespace for ServiceMonitor <code>\"\"</code> <code>serviceMonitor.labels</code> Labels for ServiceMonitor <code>{}</code> <code>serviceMonitor.interval</code> Scrape interval <code>30s</code>"},{"location":"configuration/#logging","title":"Logging","text":"Parameter Description Default <code>logging.level</code> Log level (debug, info, error) <code>info</code> <code>logging.development</code> Development mode <code>false</code> <code>logging.encoder</code> Log encoder (json, console) <code>json</code>"},{"location":"configuration/#pod-disruption-budget","title":"Pod Disruption Budget","text":"Parameter Description Default <code>podDisruptionBudget.enabled</code> Enable PDB <code>false</code> <code>podDisruptionBudget.minAvailable</code> Minimum available pods <code>1</code>"},{"location":"configuration/#scheduling","title":"Scheduling","text":"Parameter Description Default <code>nodeSelector</code> Node selector for scheduling <code>{}</code> <code>tolerations</code> Tolerations for scheduling <code>[]</code> <code>affinity</code> Affinity rules for scheduling <code>{}</code> <code>priorityClassName</code> Priority class name <code>\"\"</code>"},{"location":"configuration/#example-values-files","title":"Example Values Files","text":""},{"location":"configuration/#minimal","title":"Minimal","text":"<pre><code># values-minimal.yaml\nreplicaCount: 1\n\nwebhook:\n  certManager:\n    enabled: true\n\nlogging:\n  level: info\n</code></pre>"},{"location":"configuration/#production","title":"Production","text":"<pre><code># values-production.yaml\nreplicaCount: 3\n\nresources:\n  limits:\n    cpu: \"1\"\n    memory: 512Mi\n  requests:\n    cpu: 250m\n    memory: 256Mi\n\naffinity:\n  podAntiAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        podAffinityTerm:\n          labelSelector:\n            matchLabels:\n              app.kubernetes.io/name: vault-access-operator\n          topologyKey: kubernetes.io/hostname\n\npodDisruptionBudget:\n  enabled: true\n  minAvailable: 2\n\npriorityClassName: system-cluster-critical\n\nlogging:\n  level: info\n  encoder: json\n\nwebhook:\n  enabled: true\n  failurePolicy: Fail\n  certManager:\n    enabled: true\n\nmetrics:\n  enabled: true\n\nserviceMonitor:\n  enabled: true\n  interval: 30s\n</code></pre>"},{"location":"configuration/#development","title":"Development","text":"<pre><code># values-dev.yaml\nreplicaCount: 1\n\nlogging:\n  level: debug\n  development: true\n  encoder: console\n\nresources:\n  limits:\n    cpu: 200m\n    memory: 128Mi\n  requests:\n    cpu: 50m\n    memory: 64Mi\n\nwebhook:\n  enabled: true\n  failurePolicy: Ignore\n  certManager:\n    enabled: true\n</code></pre>"},{"location":"configuration/#without-webhooks","title":"Without Webhooks","text":"<pre><code># values-no-webhooks.yaml\nwebhook:\n  enabled: false\n</code></pre>"},{"location":"configuration/#without-cert-manager","title":"Without cert-manager","text":"Self-signed CertificatesDisable Webhooks <pre><code># values-self-signed.yaml\nwebhook:\n  enabled: true\n  certManager:\n    enabled: false\n  selfSigned:\n    enabled: true\n    validityDays: 365\n</code></pre> <pre><code># values-no-webhooks.yaml\nwebhook:\n  enabled: false\n</code></pre>"},{"location":"configuration/#with-prometheus-monitoring","title":"With Prometheus Monitoring","text":"<pre><code># values-monitoring.yaml\nmetrics:\n  enabled: true\n  secure: true\n  port: 8443\n\nserviceMonitor:\n  enabled: true\n  namespace: monitoring\n  labels:\n    release: prometheus\n  interval: 30s\n  scrapeTimeout: 10s\n</code></pre>"},{"location":"configuration/#air-gapped-environment","title":"Air-gapped Environment","text":"<pre><code># values-airgapped.yaml\nimage:\n  repository: internal-registry.example.com/vault-access-operator\n  pullPolicy: IfNotPresent\n  tag: \"v0.1.0\"\n\nimagePullSecrets:\n  - name: internal-registry-creds\n\nwebhook:\n  certManager:\n    enabled: false\n  selfSigned:\n    enabled: true\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation guide</li> <li>API Reference - CRD documentation</li> <li>Examples - CRD usage examples</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This page provides complete CRD examples for various deployment scenarios.</p>"},{"location":"examples/#vaultconnection-examples","title":"VaultConnection Examples","text":""},{"location":"examples/#basic-kubernetes-auth","title":"Basic Kubernetes Auth","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    kubernetes:\n      role: vault-access-operator\n  healthCheckInterval: 30s\n</code></pre>"},{"location":"examples/#with-tls-ca-certificate","title":"With TLS CA Certificate","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-with-tls\nspec:\n  address: https://vault.internal:8200\n  auth:\n    kubernetes:\n      role: vault-access-operator\n      authPath: kubernetes\n  tls:\n    skipVerify: false\n    caSecretRef:\n      name: vault-ca-cert\n      namespace: vault-access-operator-system\n      key: ca.crt\n</code></pre>"},{"location":"examples/#bootstrap-with-token","title":"Bootstrap with Token","text":"<p>Use a one-time token to bootstrap Kubernetes auth:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-bootstrap\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    bootstrap:\n      secretRef:\n        name: vault-bootstrap-token\n        namespace: vault-access-operator-system\n        key: token\n      autoRevoke: true\n    kubernetes:\n      role: vault-access-operator\n</code></pre>"},{"location":"examples/#approle-authentication","title":"AppRole Authentication","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-approle\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    appRole:\n      roleId: \"your-role-id\"\n      secretIdRef:\n        name: vault-approle-secret\n        namespace: vault-access-operator-system\n        key: secret-id\n      mountPath: approle\n</code></pre>"},{"location":"examples/#jwt-auth-with-tokenrequest-api","title":"JWT Auth with TokenRequest API","text":"<p>Use short-lived Kubernetes service account tokens for JWT authentication:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: jwt-tokenrequest\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    jwt:\n      role: my-jwt-role\n      audiences: [\"vault\"]\n      tokenDuration: 30m\n      userClaim: sub\n      groupsClaim: groups\n</code></pre>"},{"location":"examples/#jwt-auth-with-external-provider-aws-cognito","title":"JWT Auth with External Provider (AWS Cognito)","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: jwt-cognito\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    jwt:\n      role: cognito-role\n      jwtSecretRef:\n        name: cognito-token\n        namespace: vault-access-operator-system\n        key: id_token\n      expectedIssuer: \"https://cognito-idp.us-west-2.amazonaws.com/us-west-2_EXAMPLE\"\n      expectedAudience: \"client-id\"\n      userClaim: \"cognito:username\"\n      groupsClaim: \"cognito:groups\"\n</code></pre>"},{"location":"examples/#oidc-auth-for-eks-workload-identity","title":"OIDC Auth for EKS (Workload Identity)","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: eks-oidc\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    oidc:\n      role: eks-workload-role\n      providerURL: https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n      audiences: [\"sts.amazonaws.com\"]\n      tokenDuration: 1h\n</code></pre>"},{"location":"examples/#oidc-auth-for-azure-ad","title":"OIDC Auth for Azure AD","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: azure-oidc\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    oidc:\n      role: azure-role\n      providerURL: https://login.microsoftonline.com/TENANT-ID/v2.0\n      jwtSecretRef:\n        name: azure-token\n        namespace: vault-access-operator-system\n        key: access_token\n      userClaim: preferred_username\n      groupsClaim: groups\n</code></pre>"},{"location":"examples/#aws-iam-auth-eks-with-irsa","title":"AWS IAM Auth (EKS with IRSA)","text":"<p>For EKS workloads using IAM Roles for Service Accounts:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: aws-iam\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    aws:\n      role: eks-iam-role\n      authType: iam\n      region: us-west-2\n</code></pre>"},{"location":"examples/#aws-iam-auth-with-custom-sts-endpoint","title":"AWS IAM Auth with Custom STS Endpoint","text":"<p>For VPC endpoints or private clusters:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: aws-iam-private\nspec:\n  address: https://vault.internal:8200\n  auth:\n    aws:\n      role: eks-iam-role\n      authType: iam\n      region: us-west-2\n      stsEndpoint: https://sts.us-west-2.amazonaws.com\n      iamServerIdHeaderValue: vault.example.com\n</code></pre>"},{"location":"examples/#gcp-iam-auth-gke-with-workload-identity","title":"GCP IAM Auth (GKE with Workload Identity)","text":"<p>For GKE workloads using Workload Identity:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: gcp-iam\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    gcp:\n      role: gke-workload-role\n      authType: iam\n      serviceAccountEmail: vault-auth@my-project.iam.gserviceaccount.com\n</code></pre>"},{"location":"examples/#gcp-auth-with-service-account-key","title":"GCP Auth with Service Account Key","text":"<p>For environments without Workload Identity:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: gcp-sa-key\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    gcp:\n      role: gcp-role\n      authType: iam\n      credentialsSecretRef:\n        name: gcp-credentials\n        namespace: vault-access-operator-system\n        key: credentials.json\n</code></pre>"},{"location":"examples/#vaultpolicy-examples","title":"VaultPolicy Examples","text":""},{"location":"examples/#simple-read-policy","title":"Simple Read Policy","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: app-secrets\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [read, list]\n      description: \"Read application secrets\"\n</code></pre>"},{"location":"examples/#full-crud-access","title":"Full CRUD Access","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: app-full-access\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  enforceNamespaceBoundary: true\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [create, read, update, delete, list]\n      description: \"Full access to namespace secrets\"\n    - path: \"secret/metadata/{{namespace}}/*\"\n      capabilities: [read, list, delete]\n      description: \"Manage secret metadata\"\n</code></pre>"},{"location":"examples/#transit-encryption-policy","title":"Transit Encryption Policy","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: transit-encrypt\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"transit/encrypt/{{namespace}}-key\"\n      capabilities: [update]\n      description: \"Encrypt data\"\n    - path: \"transit/decrypt/{{namespace}}-key\"\n      capabilities: [update]\n      description: \"Decrypt data\"\n</code></pre>"},{"location":"examples/#retain-on-delete","title":"Retain on Delete","text":"<p>Keep the policy in Vault when the Kubernetes resource is deleted:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: persistent-policy\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  deletionPolicy: Retain\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [read]\n</code></pre>"},{"location":"examples/#vaultclusterpolicy-examples","title":"VaultClusterPolicy Examples","text":""},{"location":"examples/#shared-secrets-reader","title":"Shared Secrets Reader","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: shared-secrets-reader\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/shared/*\"\n      capabilities: [read, list]\n      description: \"Read shared configuration\"\n    - path: \"secret/data/global/config\"\n      capabilities: [read]\n      description: \"Read global config\"\n</code></pre>"},{"location":"examples/#platform-admin-policy","title":"Platform Admin Policy","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: platform-admin\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/*\"\n      capabilities: [create, read, update, delete, list]\n    - path: \"auth/kubernetes/role/*\"\n      capabilities: [read, list]\n    - path: \"sys/policies/acl/*\"\n      capabilities: [read, list]\n</code></pre>"},{"location":"examples/#cicd-pipeline-secrets","title":"CI/CD Pipeline Secrets","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: cicd-secrets\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/cicd/*\"\n      capabilities: [read, list]\n      description: \"Read CI/CD secrets\"\n    - path: \"secret/data/docker-registry\"\n      capabilities: [read]\n      description: \"Docker registry credentials\"\n</code></pre>"},{"location":"examples/#pki-certificate-issuer","title":"PKI Certificate Issuer","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: pki-issuer\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"pki/issue/internal\"\n      capabilities: [create, update]\n      description: \"Issue internal certificates\"\n    - path: \"pki/ca/pem\"\n      capabilities: [read]\n      description: \"Read CA certificate\"\n</code></pre>"},{"location":"examples/#vaultrole-examples","title":"VaultRole Examples","text":""},{"location":"examples/#basic-application-role","title":"Basic Application Role","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: app-role\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - default\n  policies:\n    - kind: VaultPolicy\n      name: app-secrets\n  tokenTTL: 1h\n  tokenMaxTTL: 4h\n</code></pre>"},{"location":"examples/#multiple-service-accounts","title":"Multiple Service Accounts","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: backend-services\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - api-server\n    - worker\n    - scheduler\n  policies:\n    - kind: VaultPolicy\n      name: backend-secrets\n  tokenTTL: 30m\n</code></pre>"},{"location":"examples/#mixed-policy-types","title":"Mixed Policy Types","text":"<p>Combine namespace-scoped and cluster-wide policies:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: full-access\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - default\n  policies:\n    - kind: VaultPolicy\n      name: app-secrets\n    - kind: VaultClusterPolicy\n      name: shared-config-reader\n    - kind: VaultClusterPolicy\n      name: database-readonly\n  tokenTTL: 1h\n</code></pre>"},{"location":"examples/#short-lived-tokens-for-batch-jobs","title":"Short-lived Tokens for Batch Jobs","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: batch-job\n  namespace: batch\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - batch-runner\n  policies:\n    - kind: VaultPolicy\n      name: batch-secrets\n  tokenTTL: 5m\n  tokenMaxTTL: 15m\n</code></pre>"},{"location":"examples/#vaultclusterrole-examples","title":"VaultClusterRole Examples","text":""},{"location":"examples/#platform-services-role","title":"Platform Services Role","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterRole\nmetadata:\n  name: platform-services\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - name: platform-controller\n      namespace: platform-system\n    - name: monitoring-agent\n      namespace: monitoring\n    - name: logging-collector\n      namespace: logging\n  policies:\n    - kind: VaultClusterPolicy\n      name: shared-secrets-reader\n  tokenTTL: 1h\n  tokenMaxTTL: 24h\n</code></pre>"},{"location":"examples/#cicd-pipeline-role","title":"CI/CD Pipeline Role","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterRole\nmetadata:\n  name: cicd-pipeline\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - name: tekton-pipeline\n      namespace: tekton-pipelines\n    - name: argo-workflow\n      namespace: argo\n    - name: github-actions-runner\n      namespace: actions-runner-system\n  policies:\n    - kind: VaultClusterPolicy\n      name: cicd-secrets\n  tokenTTL: 15m\n  tokenMaxTTL: 1h\n</code></pre>"},{"location":"examples/#ingress-controller-role","title":"Ingress Controller Role","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterRole\nmetadata:\n  name: ingress-controller\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - name: nginx-ingress-controller\n      namespace: ingress-nginx\n  policies:\n    - kind: VaultClusterPolicy\n      name: pki-issuer\n  tokenTTL: 30m\n</code></pre>"},{"location":"examples/#external-secrets-operator-role","title":"External Secrets Operator Role","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterRole\nmetadata:\n  name: external-secrets\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - name: external-secrets\n      namespace: external-secrets\n  policies:\n    - kind: VaultClusterPolicy\n      name: secrets-reader-all\n  tokenTTL: 1h\n  tokenMaxTTL: 4h\n</code></pre>"},{"location":"examples/#complete-application-setup","title":"Complete Application Setup","text":"<p>A complete example for setting up Vault access for a microservices application:</p> <pre><code>---\n# 1. Shared policy for all services\napiVersion: vault.platform.io/v1alpha1\nkind: VaultClusterPolicy\nmetadata:\n  name: shared-config\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/shared/database\"\n      capabilities: [read]\n    - path: \"secret/data/shared/messaging\"\n      capabilities: [read]\n---\n# 2. Namespace-specific policy\napiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: api-service\n  namespace: production\nspec:\n  connectionRef: vault-primary\n  enforceNamespaceBoundary: true\n  rules:\n    - path: \"secret/data/{{namespace}}/api/*\"\n      capabilities: [read, list]\n---\n# 3. Role binding for API service\napiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: api-service\n  namespace: production\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - api-service\n  policies:\n    - kind: VaultPolicy\n      name: api-service\n    - kind: VaultClusterPolicy\n      name: shared-config\n  tokenTTL: 1h\n---\n# 4. Service account for the application\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-service\n  namespace: production\n---\n# 5. Application deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api-service\n  namespace: production\nspec:\n  selector:\n    matchLabels:\n      app: api-service\n  template:\n    metadata:\n      labels:\n        app: api-service\n    spec:\n      serviceAccountName: api-service\n      containers:\n        - name: api\n          image: my-api:latest\n          env:\n            - name: VAULT_ADDR\n              value: \"https://vault.example.com:8200\"\n            - name: VAULT_AUTH_ROLE\n              value: \"production-api-service\"\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation guide</li> <li>API Reference - CRD field documentation</li> <li>Configuration - Helm chart options</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing the Vault Access Operator and creating your first resources.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<ul> <li>Kubernetes v1.25 or later</li> <li><code>kubectl</code> configured to access your cluster</li> <li>Cluster admin permissions for installing CRDs</li> </ul> <pre><code>kubectl version\nkubectl cluster-info\n</code></pre>"},{"location":"getting-started/#hashicorp-vault","title":"HashiCorp Vault","text":"<ul> <li>Vault server v1.12 or later</li> <li>Vault unsealed and accessible from your Kubernetes cluster</li> <li>Kubernetes authentication method enabled</li> </ul> <p>To enable the Kubernetes auth method in Vault:</p> <pre><code>vault auth enable kubernetes\n\nvault write auth/kubernetes/config \\\n    kubernetes_host=\"https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT\" \\\n    kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n</code></pre>"},{"location":"getting-started/#cert-manager-optional","title":"cert-manager (Optional)","text":"<p>cert-manager is recommended for managing webhook certificates:</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.0/cert-manager.yaml\nkubectl wait --for=condition=Available deployment --all -n cert-manager --timeout=300s\n</code></pre> <p>Without cert-manager</p> <p>You can disable webhooks or use self-signed certificates. See Configuration for details.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"Helm (Recommended)kubectlFrom Source <pre><code>helm install vault-access-operator \\\n  oci://ghcr.io/panteparak/vault-access-operator/charts/vault-access-operator \\\n  --namespace vault-access-operator-system \\\n  --create-namespace\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/panteparak/vault-access-operator/main/dist/install.yaml\n</code></pre> <pre><code>git clone https://github.com/panteparak/vault-access-operator.git\ncd vault-access-operator\nmake install\nmake deploy IMG=ghcr.io/panteparak/vault-access-operator:latest\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code># Check operator pod\nkubectl get pods -n vault-access-operator-system\n\n# Check CRDs\nkubectl get crds | grep vault.platform.io\n</code></pre>"},{"location":"getting-started/#configure-vault-for-the-operator","title":"Configure Vault for the Operator","text":"<p>Before creating resources, configure Vault to allow the operator to manage policies and roles.</p> <p>Security Notice: Never Use Root Token</p> <p>The operator should never use the Vault root token in production. Always use a dedicated service account with the minimum required permissions as described below.</p>"},{"location":"getting-started/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>The Vault Access Operator follows the Principle of Least Privilege\u2014it only requests the minimum permissions necessary to perform its job. Understanding these permissions helps you:</p> <ol> <li>Audit what the operator can and cannot do</li> <li>Trust that secrets are not directly accessible to the operator</li> <li>Comply with security requirements in regulated environments</li> </ol>"},{"location":"getting-started/#what-the-operator-needs","title":"What the Operator Needs","text":"Path Capabilities Purpose <code>sys/policies/acl/*</code> create, read, update, delete, list Manage Vault policies <code>sys/policies/acl</code> list List existing policies <code>auth/kubernetes/role/*</code> create, read, update, delete, list Manage Kubernetes auth roles <code>auth/kubernetes/role</code> list List existing roles <code>auth/kubernetes/config</code> read, update Configure Kubernetes auth method <code>sys/health</code> read Health checks for connection status"},{"location":"getting-started/#what-the-operator-does-not-need","title":"What the Operator Does NOT Need","text":"Path Reason <code>secret/*</code> The operator manages access to secrets, not the secrets themselves <code>sys/seal</code>, <code>sys/unseal</code> Administrative operations only <code>sys/init</code> Vault initialization is out of scope <code>identity/*</code> Entity/alias management not required Root capability Never required for normal operation"},{"location":"getting-started/#create-operator-policy","title":"Create Operator Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\n# Manage policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# Manage Kubernetes auth roles\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\n\n# Configure Kubernetes auth method (optional, for initial setup)\npath \"auth/kubernetes/config\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\"]\n}\n\n# Enable/disable auth methods (optional, for bootstrapping)\npath \"sys/auth\" {\n  capabilities = [\"read\"]\n}\npath \"sys/auth/*\" {\n  capabilities = [\"sudo\", \"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\n\n# Health check\npath \"sys/health\" {\n  capabilities = [\"read\"]\n}\nEOF\n</code></pre> <p>Verify Token Capabilities</p> <p>You can verify what a token can access using: <pre><code># Check capabilities on a specific path\nvault token capabilities &lt;token&gt; sys/policies/acl/test\n# Expected: create, delete, list, read, update\n\n# Verify secrets are denied\nvault token capabilities &lt;token&gt; secret/data/test\n# Expected: deny\n</code></pre></p>"},{"location":"getting-started/#create-kubernetes-auth-role","title":"Create Kubernetes Auth Role","text":"<pre><code>vault write auth/kubernetes/role/vault-access-operator \\\n    bound_service_account_names=vault-access-operator-controller-manager \\\n    bound_service_account_namespaces=vault-access-operator-system \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre>"},{"location":"getting-started/#choosing-an-authentication-method","title":"Choosing an Authentication Method","text":"<p>The operator supports multiple authentication methods. Choose based on your environment:</p> Method Best For Prerequisites Kubernetes Standard K8s deployments Vault K8s auth configured JWT External identity providers JWT auth mount in Vault OIDC EKS, AKS, GKE workload identity OIDC provider configured in Vault AWS EKS with IRSA IAM role with trust policy GCP GKE with Workload Identity GCP SA with IAM bindings Token Development/testing Vault token available AppRole Machine-to-machine AppRole credentials Bootstrap Initial setup Privileged token"},{"location":"getting-started/#when-to-use-each-method","title":"When to Use Each Method","text":"<p>Kubernetes Auth (Recommended for most cases)</p> <ul> <li>Works with any Kubernetes cluster</li> <li>Automatic token rotation via TokenRequest API</li> <li>No external dependencies beyond Vault</li> </ul> <pre><code>auth:\n  kubernetes:\n    role: vault-access-operator\n</code></pre> <p>OIDC Auth (Recommended for cloud providers)</p> <ul> <li>EKS: Use OIDC issuer URL from <code>aws eks describe-cluster</code></li> <li>GKE: Use Workload Identity federation</li> <li>AKS: Use Azure AD integration</li> </ul> <pre><code>auth:\n  oidc:\n    role: eks-workload-role\n    providerURL: https://oidc.eks.us-west-2.amazonaws.com/id/CLUSTER_ID\n</code></pre> <p>AWS Auth (EKS-specific)</p> <ul> <li>Uses IRSA (IAM Roles for Service Accounts)</li> <li>Requires IAM role with trust policy for the service account</li> <li>Auto-detects region and credentials from environment</li> </ul> <pre><code>auth:\n  aws:\n    role: eks-iam-role\n    authType: iam\n</code></pre> <p>GCP Auth (GKE-specific)</p> <ul> <li>Uses Workload Identity for automatic credential management</li> <li>Requires GCP service account binding to K8s service account</li> <li>Auto-detects credentials from metadata server</li> </ul> <pre><code>auth:\n  gcp:\n    role: gke-workload-role\n    authType: iam\n</code></pre>"},{"location":"getting-started/#token-lifecycle-management","title":"Token Lifecycle Management","text":"<p>The operator automatically manages Vault token lifecycle:</p> <ol> <li>Initial Authentication - Obtains Vault token using configured auth method</li> <li>Token Renewal - Renews token before expiration (default: 75% of TTL)</li> <li>Re-authentication - Falls back to full re-auth if renewal fails</li> <li>Token Reviewer Rotation - Automatically rotates token_reviewer_jwt for K8s auth</li> </ol>"},{"location":"getting-started/#monitoring-token-status","title":"Monitoring Token Status","text":"<p>Check token status in VaultConnection:</p> <pre><code>kubectl get vaultconnection my-connection -o jsonpath='{.status.authStatus}'\n</code></pre> <p>Key fields:</p> <ul> <li><code>tokenExpiration</code> - When current token expires</li> <li><code>tokenLastRenewed</code> - Last renewal time</li> <li><code>tokenRenewalCount</code> - Total renewals since last full auth</li> <li><code>tokenReviewerExpiration</code> - token_reviewer_jwt expiration (K8s auth only)</li> </ul>"},{"location":"getting-started/#token-reviewer-jwt-rotation","title":"Token Reviewer JWT Rotation","text":"<p>Important for Kubernetes Auth</p> <p>The <code>token_reviewer_jwt</code> is used by Vault to verify service account tokens. If it expires and isn't rotated, all Kubernetes authentication will fail.</p> <p>The operator automatically rotates this JWT when <code>tokenReviewerRotation: true</code> (default). You can monitor the rotation status via:</p> <pre><code>kubectl get vaultconnection my-connection -o jsonpath='{.status.authStatus.tokenReviewerExpiration}'\n</code></pre>"},{"location":"getting-started/#quick-start-create-your-first-resources","title":"Quick Start: Create Your First Resources","text":""},{"location":"getting-started/#step-1-create-a-vaultconnection","title":"Step 1: Create a VaultConnection","text":"<pre><code># vault-connection.yaml\napiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    kubernetes:\n      role: vault-access-operator\n  tls:\n    skipVerify: false  # Set to true for testing only\n</code></pre> <pre><code>kubectl apply -f vault-connection.yaml\nkubectl get vaultconnection vault-primary\n</code></pre> <p>Expected output: <pre><code>NAME            ADDRESS                          PHASE    VERSION   AGE\nvault-primary   https://vault.example.com:8200   Active   1.15.0    30s\n</code></pre></p>"},{"location":"getting-started/#step-2-create-a-vaultpolicy","title":"Step 2: Create a VaultPolicy","text":"<pre><code># app-secrets-policy.yaml\napiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: app-secrets\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [read, list]\n      description: \"Read secrets for this namespace\"\n</code></pre> <pre><code>kubectl create namespace my-app\nkubectl apply -f app-secrets-policy.yaml\nkubectl get vaultpolicy -n my-app\n</code></pre>"},{"location":"getting-started/#step-3-create-a-vaultrole","title":"Step 3: Create a VaultRole","text":"<pre><code># app-role.yaml\napiVersion: vault.platform.io/v1alpha1\nkind: VaultRole\nmetadata:\n  name: app-role\n  namespace: my-app\nspec:\n  connectionRef: vault-primary\n  serviceAccounts:\n    - default\n  policies:\n    - kind: VaultPolicy\n      name: app-secrets\n  tokenTTL: 1h\n  tokenMaxTTL: 4h\n</code></pre> <pre><code>kubectl apply -f app-role.yaml\nkubectl get vaultrole -n my-app\n</code></pre>"},{"location":"getting-started/#step-4-test-authentication","title":"Step 4: Test Authentication","text":"<pre><code># test-pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: vault-test\n  namespace: my-app\nspec:\n  serviceAccountName: default\n  containers:\n    - name: vault\n      image: hashicorp/vault:latest\n      command: [\"sleep\", \"infinity\"]\n      env:\n        - name: VAULT_ADDR\n          value: \"https://vault.example.com:8200\"\n</code></pre> <pre><code>kubectl apply -f test-pod.yaml\nkubectl exec -it vault-test -n my-app -- vault login -method=kubernetes role=my-app-app-role\n</code></pre>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>You've successfully:</p> <ol> <li>Installed the Vault Access Operator</li> <li>Connected to your Vault server using <code>VaultConnection</code></li> <li>Created a policy using <code>VaultPolicy</code></li> <li>Created a role using <code>VaultRole</code> to bind service accounts to policies</li> <li>Tested Vault authentication from a Kubernetes pod</li> </ol> Resource Scope Description VaultConnection Cluster Establishes connection to Vault VaultPolicy Namespaced Namespace-scoped Vault policy VaultClusterPolicy Cluster Cluster-wide Vault policy VaultRole Namespaced Namespace-scoped Kubernetes auth role VaultClusterRole Cluster Cluster-wide Kubernetes auth role"},{"location":"getting-started/#uninstallation","title":"Uninstallation","text":"Helmkubectl <pre><code>helm uninstall vault-access-operator -n vault-access-operator-system\n\n# Optionally delete CRDs (this deletes all managed resources!)\nkubectl delete crds \\\n  vaultconnections.vault.platform.io \\\n  vaultpolicies.vault.platform.io \\\n  vaultclusterpolicies.vault.platform.io \\\n  vaultroles.vault.platform.io \\\n  vaultclusterroles.vault.platform.io\n\nkubectl delete namespace vault-access-operator-system\n</code></pre> <pre><code>kubectl delete -f https://raw.githubusercontent.com/panteparak/vault-access-operator/main/dist/install.yaml\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Helm chart options</li> <li>API Reference - Detailed CRD documentation</li> <li>Examples - More usage examples</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"test-evaluation/","title":"E2E vs Integration Test Evaluation","text":""},{"location":"test-evaluation/#evaluation-criteria","title":"Evaluation Criteria","text":"Criteria E2E Required Integration OK Real K8s networking (Service DNS) \u2705 \u274c kubectl exec into pods \u2705 \u274c K8s auth method (TokenReview API) \u2705 \u274c Operator deployed as real pod \u2705 \u274c Controller reconciliation logic \u2705 \u2705 Vault API interactions \u2705 \u2705 CRD validation/webhooks \u2705 \u2705 Error handling paths \u2705 \u2705 Simple permission checks \u274c \u2705"},{"location":"test-evaluation/#test-case-evaluation","title":"Test Case Evaluation","text":""},{"location":"test-evaluation/#1-tc_connection_testgo-2-tests","title":"1. tc_connection_test.go (2 tests)","text":"Test Verdict Reason TC-VC01: Create VaultConnection with token auth E2E Core CRD, needs real operator reconciliation TC-VC02: Verify VaultConnection health check E2E Tests real health check to Vault service <p>Summary: Keep ALL in E2E (2 tests) - fundamental functionality</p>"},{"location":"test-evaluation/#2-tc_policy_testgo-5-tests","title":"2. tc_policy_test.go (5 tests)","text":"Test Verdict Reason TC-VP01: Create and sync VaultPolicy E2E Core lifecycle, happy path TC-VP02: Substitute {{namespace}} variable Integration Tests string substitution logic TC-VP03: Update VaultPolicy when spec changes E2E Tests update reconciliation TC-VP04-DEL: Handle deletion with finalizer E2E Tests finalizer with real cleanup TC-VP05-RET: Respect deletionPolicy=Retain Integration Tests flag logic, no cleanup verification needed <p>Summary: E2E: 3, Integration: 2</p>"},{"location":"test-evaluation/#3-tc_cluster_policy_testgo-4-tests","title":"3. tc_cluster_policy_test.go (4 tests)","text":"Test Verdict Reason TC-CP01: Create and sync cluster policy E2E Core lifecycle TC-CP02: Verify policy HCL content E2E Part of lifecycle verification TC-CP03: Handle invalid connection reference Integration Error handling path TC-CP04: Handle empty rules Integration Validation error path <p>Summary: E2E: 2, Integration: 2</p>"},{"location":"test-evaluation/#4-tc_role_testgo-3-tests","title":"4. tc_role_test.go (3 tests)","text":"Test Verdict Reason TC-VR01: Create namespaced VaultRole E2E Core lifecycle TC-VR02: Verify role configuration E2E Verification of Vault state TC-VR03-DEL: Remove role on deletion E2E Tests cleanup in Vault <p>Summary: Keep ALL in E2E (3 tests) - core functionality with Vault state verification</p>"},{"location":"test-evaluation/#5-tc_cluster_role_testgo-5-tests","title":"5. tc_cluster_role_test.go (5 tests)","text":"Test Verdict Reason TC-CR01: Create VaultClusterRole E2E Core lifecycle TC-CR02: Verify cluster role config E2E Vault state verification TC-CR03-DEL: Remove on deletion E2E Cleanup verification TC-CR04: Handle invalid connection Integration Error handling TC-CR05: Handle missing policy ref Integration Error handling <p>Summary: E2E: 3, Integration: 2</p>"},{"location":"test-evaluation/#6-tc_conflict_testgo-3-tests","title":"6. tc_conflict_test.go (3 tests)","text":"Test Verdict Reason TC-CF01-ADOPT: Adopt existing policy E2E Tests real Vault state management TC-CF02-FAIL: Fail when policy exists E2E Tests real conflict detection TC-CF03-NORM: Create normally (no conflict) Integration Simple happy path, can use testcontainer <p>Summary: E2E: 2, Integration: 1</p>"},{"location":"test-evaluation/#7-tc_error_testgo-6-tests","title":"7. tc_error_test.go (6 tests)","text":"Test Verdict Reason TC-EH01: Invalid connection reference Integration Simple error path TC-EH02: Missing policy reference Integration Simple error path TC-EH03: Namespace boundary violation E2E Needs real RBAC enforcement TC-EH04: VaultConnection unavailable E2E Tests real connection failure handling TC-EH05: Invalid TTL format Integration Validation error TC-EH06: Empty policy rules Integration Validation error <p>Summary: E2E: 2, Integration: 4</p>"},{"location":"test-evaluation/#8-tc_auth_testgo-5-tests","title":"8. tc_auth_test.go (5 tests)","text":"Test Verdict Reason TC-AU01-01: Allow bound SA to authenticate E2E Needs real K8s auth + TokenReview TC-AU01-02: Reject incorrect SA E2E Needs real K8s auth rejection TC-AU01-03: Reject invalid JWT E2E Needs real token validation TC-AU01-04: Re-authenticate after expiration E2E Tests real token lifecycle TC-AU01-05: Multiple SAs same role E2E Needs real K8s SA tokens <p>Summary: Keep ALL in E2E (5 tests) - K8s auth method requires real TokenReview API</p>"},{"location":"test-evaluation/#9-tc_jwt_auth_testgo-7-tests","title":"9. tc_jwt_auth_test.go (7 tests)","text":"Test Verdict Reason TC-AU04-01: JWT auth with SA token E2E Needs real K8s OIDC issuer TC-AU04-02: Reject wrong audience Integration JWT validation logic TC-AU04-03: Reject wrong subject Integration JWT validation logic TC-AU05-01: Discover OIDC config E2E Tests real K8s /.well-known/openid-configuration TC-AU05-02: Auth with OIDC keys E2E Needs real JWKS endpoint TC-AU05-03: Custom audiences E2E Needs real TokenRequest API TC-AU06-01: VaultConnection with JWT E2E Tests full JWT connection flow <p>Summary: E2E: 5, Integration: 2</p>"},{"location":"test-evaluation/#10-token_lifecycle_testgo-13-tests","title":"10. token_lifecycle_test.go (13 tests)","text":"Test Verdict Reason Bootstrap: should bootstrap K8s auth E2E Core bootstrap flow Bootstrap: complete and transition E2E Bootstrap verification Bootstrap: K8s auth enabled E2E Vault state check Bootstrap: operator role created E2E Vault state check Bootstrap: not re-bootstrap E2E Idempotency test Bootstrap: token expiration info Integration Status field check Bootstrap: Vault version in status Integration Status field check K8s Auth: connect pre-configured E2E Non-bootstrap flow K8s Auth: NOT bootstrapComplete Integration Status field check K8s Auth: authMethod set Integration Status field check K8s Auth: Vault version Integration Status field check (duplicate) K8s Auth: token expiration Integration Status field check (duplicate) TC-LC07: Renew token E2E Real token renewal <p>Summary: E2E: 6, Integration: 7 (many are status field checks that could be consolidated)</p>"},{"location":"test-evaluation/#11-operator_token_testgo-10-tests","title":"11. operator_token_test.go (10 tests)","text":"Test Verdict Reason TC-OP01: create capability on policies Integration Just Vault permission check TC-OP01: list capability on policies Integration Just Vault permission check TC-OP02: CRUD on auth/kubernetes/role Integration Just Vault permission check TC-OP02: list on auth/kubernetes/role Integration Just Vault permission check TC-OP03: read on sys/health Integration Just Vault permission check TC-OP04: NOT access secret/* Integration Vault permission denial check TC-OP04: NOT access sys/seal Integration Vault permission denial check TC-OP04: NOT access sys/unseal Integration Vault permission denial check TC-OP04: NOT root capability Integration Vault permission check TC-OP05: create/read test policy Integration Functional permission test <p>Summary: Move ALL to Integration (10 tests) - only needs Vault, no K8s required</p>"},{"location":"test-evaluation/#summary-table","title":"Summary Table","text":"Test File Current E2E Keep E2E Move to Integration Status tc_connection_test.go 2 2 0 - tc_policy_test.go 5 3 2 Pending tc_cluster_policy_test.go 4 2 2 Pending tc_role_test.go 3 3 0 - tc_cluster_role_test.go 5 3 2 Pending tc_conflict_test.go 3 2 1 Pending tc_error_test.go 6 2 4 Pending tc_auth_test.go 5 5 0 - tc_jwt_auth_test.go 7 5 2 Pending token_lifecycle_test.go 13 6 7 Pending operator_token_test.go 10 0 10 \u2705 DONE TOTAL 63 33 30 10 done"},{"location":"test-evaluation/#completed-migrations","title":"Completed Migrations","text":""},{"location":"test-evaluation/#operator_token_testgo-10-tests","title":"operator_token_test.go (10 tests) \u2705","text":"<ul> <li>Location: <code>test/integration/permissions/operator_token_test.go</code></li> <li>New infrastructure: Added <code>WithVaultOnly()</code> option for Vault-only tests</li> <li>Test time: ~5.7 seconds (vs ~30s+ for E2E setup)</li> </ul>"},{"location":"test-evaluation/#recommended-actions","title":"Recommended Actions","text":"<ol> <li>~~Move operator_token_test.go entirely to <code>test/integration/permissions/</code>~~ \u2705 DONE</li> <li>Create <code>test/integration/error/</code> for error handling tests</li> <li>Create <code>test/integration/validation/</code> for validation tests (some exist in security/)</li> <li>Consolidate token_lifecycle status checks - many are duplicates</li> <li>Keep K8s auth tests in E2E - TokenReview API requires real K8s</li> </ol>"},{"location":"test-evaluation/#result","title":"Result","text":"<ul> <li>E2E tests reduced from 63 to 33 (~48% reduction)</li> <li>CI time should improve significantly</li> <li>Integration tests provide faster feedback for error/validation paths</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and resolve common issues with the Vault Access Operator.</p>"},{"location":"troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Common Issues</li> <li>VaultConnection Issues</li> <li>VaultPolicy Issues</li> <li>VaultRole Issues</li> <li>Webhook Issues</li> <li>Debugging Techniques</li> <li>Log Analysis</li> <li>Status Conditions Explained</li> </ul>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#vaultconnection-issues","title":"VaultConnection Issues","text":""},{"location":"troubleshooting/#connection-stuck-in-pending-phase","title":"Connection Stuck in \"Pending\" Phase","text":"<p>Symptoms: <pre><code>kubectl get vaultconnection\nNAME            ADDRESS                          PHASE     VERSION   AGE\nvault-primary   https://vault.example.com:8200   Pending             5m\n</code></pre></p> <p>Possible Causes:</p> <ol> <li> <p>Operator not running: Check if the operator pod is running.    <pre><code>kubectl get pods -n vault-access-operator-system\n</code></pre></p> </li> <li> <p>Invalid Vault address: Verify the address is correct and reachable.    <pre><code>kubectl describe vaultconnection vault-primary\n</code></pre></p> </li> <li> <p>Network connectivity: The operator cannot reach Vault.    <pre><code># Test from a pod in the same namespace as the operator\nkubectl run -it --rm debug --image=curlimages/curl -- curl -k https://vault.example.com:8200/v1/sys/health\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#connection-in-error-phase","title":"Connection in \"Error\" Phase","text":"<p>Symptoms: <pre><code>kubectl get vaultconnection\nNAME            ADDRESS                          PHASE   VERSION   AGE\nvault-primary   https://vault.example.com:8200   Error             5m\n</code></pre></p> <p>Check the error message: <pre><code>kubectl describe vaultconnection vault-primary\n</code></pre></p> <p>Common error causes:</p> <ol> <li>TLS Certificate Issues</li> <li>Error: <code>x509: certificate signed by unknown authority</code></li> <li> <p>Solution: Provide the correct CA certificate or set <code>skipVerify: true</code> (not recommended for production).    <pre><code>spec:\n  tls:\n    caSecretRef:\n      name: vault-ca-cert\n      namespace: vault-access-operator-system\n      key: ca.crt\n</code></pre></p> </li> <li> <p>Authentication Failure</p> </li> <li>Error: <code>permission denied</code> or <code>invalid role</code></li> <li> <p>Solution: Verify the Vault role exists and the service account is bound correctly.    <pre><code># Check if the role exists in Vault\nvault read auth/kubernetes/role/vault-access-operator\n\n# Verify the operator service account\nkubectl get sa -n vault-access-operator-system\n</code></pre></p> </li> <li> <p>Vault Sealed</p> </li> <li>Error: <code>Vault is sealed</code></li> <li>Solution: Unseal the Vault server.    <pre><code>vault status\nvault operator unseal\n</code></pre></li> </ol>"},{"location":"troubleshooting/#connection-authentication-failures","title":"Connection Authentication Failures","text":"<p>Symptoms: <pre><code>Error: failed to authenticate: permission denied\n</code></pre></p> <p>Debugging steps:</p> <ol> <li> <p>Verify Kubernetes auth is enabled: <pre><code>vault auth list\n</code></pre></p> </li> <li> <p>Check the Vault role configuration: <pre><code>vault read auth/kubernetes/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Verify service account binding: <pre><code># The role should allow:\n# - bound_service_account_names: vault-access-operator-controller-manager\n# - bound_service_account_namespaces: vault-access-operator-system\n</code></pre></p> </li> <li> <p>Test authentication manually: <pre><code># Get a shell in the operator pod\nkubectl exec -it deploy/vault-access-operator-controller-manager \\\n  -n vault-access-operator-system -- /bin/sh\n\n# Check the service account token\ncat /var/run/secrets/kubernetes.io/serviceaccount/token\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#vaultpolicy-issues","title":"VaultPolicy Issues","text":""},{"location":"troubleshooting/#policy-stuck-in-syncing-phase","title":"Policy Stuck in \"Syncing\" Phase","text":"<p>Symptoms: <pre><code>kubectl get vaultpolicy -n my-app\nNAME          VAULT NAME         PHASE     RULES   AGE\napp-secrets   my-app-app-secrets Syncing   3       5m\n</code></pre></p> <p>Possible causes:</p> <ol> <li> <p>VaultConnection not ready: <pre><code>kubectl get vaultconnection\n# Ensure the referenced connection is in \"Active\" phase\n</code></pre></p> </li> <li> <p>Insufficient Vault permissions: <pre><code># Check operator logs\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager\n\n# Ensure the Vault policy allows policy management\nvault policy read vault-access-operator\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#policy-in-conflict-phase","title":"Policy in \"Conflict\" Phase","text":"<p>Symptoms: <pre><code>kubectl get vaultpolicy -n my-app\nNAME          VAULT NAME         PHASE      RULES   AGE\napp-secrets   my-app-app-secrets Conflict   3       5m\n</code></pre></p> <p>Explanation: A policy with the same name already exists in Vault and is either: - Managed by a different Kubernetes resource - Not managed by the operator at all</p> <p>Solutions:</p> <ol> <li> <p>Use Adopt conflict policy: <pre><code>spec:\n  conflictPolicy: Adopt  # Take over the existing policy\n</code></pre></p> </li> <li> <p>Delete the existing policy from Vault: <pre><code>vault policy delete my-app-app-secrets\n</code></pre></p> </li> <li> <p>Rename your VaultPolicy resource: <pre><code>metadata:\n  name: app-secrets-v2  # Will create: my-app-app-secrets-v2\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#namespace-boundary-validation-error","title":"Namespace Boundary Validation Error","text":"<p>Symptoms: <pre><code>Error: validation failed: rule[0]: path \"secret/data/*\" must contain {{namespace}} when namespace boundary enforcement is enabled\n</code></pre></p> <p>Solution: Add the <code>{{namespace}}</code> variable to your paths, or disable namespace boundary enforcement:</p> <p>Option 1: Add namespace variable (recommended for multi-tenant environments): <pre><code>spec:\n  enforceNamespaceBoundary: true  # Explicitly enabled (default is false)\n  rules:\n    - path: \"secret/data/{{namespace}}/*\"  # Correct\n      capabilities: [read, list]\n</code></pre></p> <p>Option 2: Disable enforcement (default behavior): <pre><code>spec:\n  enforceNamespaceBoundary: false  # This is the default\n  rules:\n    - path: \"secret/data/*\"\n      capabilities: [read, list]\n</code></pre></p>"},{"location":"troubleshooting/#wildcard-before-namespace-error","title":"Wildcard Before Namespace Error","text":"<p>Symptoms: <pre><code>Error: validation failed: rule[0]: path \"secret/*/{{namespace}}/data\" contains wildcard (*) before {{namespace}} which is a security risk\n</code></pre></p> <p>Explanation: Having a wildcard before <code>{{namespace}}</code> could allow access to secrets in other namespaces.</p> <p>Solution: Restructure your path: <pre><code># Bad\n- path: \"secret/*/{{namespace}}/data\"\n\n# Good\n- path: \"secret/data/{{namespace}}/*\"\n- path: \"kv/{{namespace}}/data/*\"\n</code></pre></p>"},{"location":"troubleshooting/#vaultrole-issues","title":"VaultRole Issues","text":""},{"location":"troubleshooting/#role-in-error-phase-with-policynotfound","title":"Role in \"Error\" Phase with PolicyNotFound","text":"<p>Symptoms: <pre><code>kubectl describe vaultrole app-role -n my-app\n# Status shows: policy VaultPolicy \"missing-policy\" not found in namespace \"my-app\"\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Create the missing policy: <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: missing-policy\n  namespace: my-app\nspec:\n  # ... policy configuration\n</code></pre></p> </li> <li> <p>Fix the policy reference: <pre><code>spec:\n  policies:\n    - kind: VaultPolicy\n      name: correct-policy-name\n</code></pre></p> </li> <li> <p>If referencing a policy in another namespace: <pre><code>spec:\n  policies:\n    - kind: VaultPolicy\n      name: shared-policy\n      namespace: shared-namespace\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#service-account-not-authorized","title":"Service Account Not Authorized","text":"<p>Symptoms: - Application pods cannot authenticate to Vault - Error: <code>role not found</code> or <code>service account not authorized</code></p> <p>Debugging steps:</p> <ol> <li> <p>Check the VaultRole status: <pre><code>kubectl get vaultrole app-role -n my-app -o yaml\n# Verify boundServiceAccounts in status\n</code></pre></p> </li> <li> <p>Verify the service account exists: <pre><code>kubectl get sa -n my-app\n</code></pre></p> </li> <li> <p>Check the role in Vault: <pre><code>vault read auth/kubernetes/role/my-app-app-role\n</code></pre></p> </li> <li> <p>Test authentication: <pre><code>kubectl run -it --rm debug \\\n  --image=hashicorp/vault \\\n  --serviceaccount=app-service-account \\\n  -n my-app -- \\\n  vault login -method=kubernetes role=my-app-app-role\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#webhook-issues","title":"Webhook Issues","text":""},{"location":"troubleshooting/#webhook-certificate-errors","title":"Webhook Certificate Errors","text":"<p>Symptoms: <pre><code>Error creating: Internal error occurred: failed calling webhook:\nx509: certificate signed by unknown authority\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>If using cert-manager, verify the certificate: <pre><code>kubectl get certificate -n vault-access-operator-system\nkubectl describe certificate vault-access-operator-webhook-cert \\\n  -n vault-access-operator-system\n</code></pre></p> </li> <li> <p>Check cert-manager is working: <pre><code>kubectl get pods -n cert-manager\nkubectl logs -n cert-manager deploy/cert-manager\n</code></pre></p> </li> <li> <p>Restart the operator to pick up new certificate: <pre><code>kubectl rollout restart deployment vault-access-operator-controller-manager \\\n  -n vault-access-operator-system\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#webhook-timeout","title":"Webhook Timeout","text":"<p>Symptoms: <pre><code>Error: context deadline exceeded (Client.Timeout exceeded while awaiting headers)\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check operator health: <pre><code>kubectl get pods -n vault-access-operator-system\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager\n</code></pre></p> </li> <li> <p>Increase webhook timeout: <pre><code># In Helm values\nwebhook:\n  timeoutSeconds: 30\n</code></pre></p> </li> <li> <p>Check network policies: <pre><code>kubectl get networkpolicy -n vault-access-operator-system\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>Increase log verbosity for more detailed output:</p> <pre><code># Helm values\nlogging:\n  level: debug\n</code></pre> <p>Or set environment variable: <pre><code>kubectl set env deployment/vault-access-operator-controller-manager \\\n  -n vault-access-operator-system \\\n  -- ZAP_LOG_LEVEL=debug\n</code></pre></p>"},{"location":"troubleshooting/#check-resource-events","title":"Check Resource Events","text":"<pre><code>kubectl get events --field-selector involvedObject.name=app-secrets -n my-app\n</code></pre>"},{"location":"troubleshooting/#inspect-resource-details","title":"Inspect Resource Details","text":"<pre><code># Full resource with status\nkubectl get vaultpolicy app-secrets -n my-app -o yaml\n\n# Just the status\nkubectl get vaultpolicy app-secrets -n my-app -o jsonpath='{.status}'\n\n# Just conditions\nkubectl get vaultpolicy app-secrets -n my-app \\\n  -o jsonpath='{.status.conditions}' | jq .\n</code></pre>"},{"location":"troubleshooting/#test-vault-connectivity-from-operator","title":"Test Vault Connectivity from Operator","text":"<pre><code># Get a shell in the operator pod\nkubectl exec -it deploy/vault-access-operator-controller-manager \\\n  -n vault-access-operator-system -- /bin/sh\n\n# Test Vault health\nwget -qO- https://vault.example.com:8200/v1/sys/health\n\n# Check environment\nenv | grep VAULT\n</code></pre>"},{"location":"troubleshooting/#verify-crd-installation","title":"Verify CRD Installation","text":"<pre><code># List CRDs\nkubectl get crds | grep vault.platform.io\n\n# Check CRD details\nkubectl describe crd vaultpolicies.vault.platform.io\n</code></pre>"},{"location":"troubleshooting/#log-analysis","title":"Log Analysis","text":""},{"location":"troubleshooting/#operator-log-locations","title":"Operator Log Locations","text":"<pre><code># Stream logs from the operator\nkubectl logs -f -n vault-access-operator-system deploy/vault-access-operator-controller-manager\n\n# Get logs from the last hour\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  --since=1h\n\n# Get logs from a crashed pod\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  --previous\n</code></pre>"},{"location":"troubleshooting/#common-log-patterns","title":"Common Log Patterns","text":""},{"location":"troubleshooting/#successful-reconciliation","title":"Successful Reconciliation","text":"<pre><code>{\"level\":\"info\",\"ts\":\"...\",\"msg\":\"Reconciling VaultPolicy\",\"namespace\":\"my-app\",\"name\":\"app-secrets\"}\n{\"level\":\"info\",\"ts\":\"...\",\"msg\":\"VaultPolicy reconciled successfully\",\"namespace\":\"my-app\",\"name\":\"app-secrets\",\"vaultName\":\"my-app-app-secrets\"}\n</code></pre>"},{"location":"troubleshooting/#connection-error","title":"Connection Error","text":"<pre><code>{\"level\":\"error\",\"ts\":\"...\",\"msg\":\"Failed to get Vault client\",\"error\":\"connection \\\"vault-primary\\\" not ready: VaultConnection is in Pending phase\"}\n</code></pre>"},{"location":"troubleshooting/#conflict-detection","title":"Conflict Detection","text":"<pre><code>{\"level\":\"error\",\"ts\":\"...\",\"msg\":\"Conflict detected\",\"error\":\"conflict: policy \\\"my-app-app-secrets\\\": already managed by other-namespace/other-policy\"}\n</code></pre>"},{"location":"troubleshooting/#retry-scheduling","title":"Retry Scheduling","text":"<pre><code>{\"level\":\"info\",\"ts\":\"...\",\"msg\":\"Scheduling retry\",\"retryCount\":2,\"nextRetryIn\":\"20s\"}\n</code></pre>"},{"location":"troubleshooting/#filtering-logs","title":"Filtering Logs","text":"<pre><code># Only errors\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  | grep '\"level\":\"error\"'\n\n# Specific resource\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  | grep '\"name\":\"app-secrets\"'\n\n# Using jq for JSON logs\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  | jq 'select(.level == \"error\")'\n</code></pre>"},{"location":"troubleshooting/#status-conditions-explained","title":"Status Conditions Explained","text":""},{"location":"troubleshooting/#condition-types","title":"Condition Types","text":"Type Description Healthy State <code>Ready</code> Resource is fully reconciled and operational <code>True</code> <code>Synced</code> Resource has been successfully synced to Vault <code>True</code> <code>ConnectionReady</code> Referenced VaultConnection is available <code>True</code> <code>PoliciesResolved</code> All referenced policies have been found and resolved <code>True</code>"},{"location":"troubleshooting/#condition-reasons","title":"Condition Reasons","text":"Reason Description Action <code>Succeeded</code> Operation completed successfully None needed <code>Failed</code> Operation failed Check message and logs <code>InProgress</code> Operation is ongoing Wait for completion <code>Conflict</code> Conflict with existing Vault resource Use Adopt policy or resolve manually <code>ValidationFailed</code> Resource spec validation failed Fix spec according to error <code>ConnectionNotReady</code> VaultConnection is not active Fix VaultConnection <code>PolicyNotFound</code> Referenced policy doesn't exist Create the policy"},{"location":"troubleshooting/#reading-conditions","title":"Reading Conditions","text":"<pre><code># Get all conditions\nkubectl get vaultpolicy app-secrets -n my-app \\\n  -o jsonpath='{range .status.conditions[*]}{.type}: {.status} ({.reason}) - {.message}{\"\\n\"}{end}'\n\n# Example output:\n# Ready: False (ConnectionNotReady) - connection \"vault-primary\" not ready: VaultConnection is in Error phase\n# Synced: False (Failed) - failed to sync policy to Vault\n</code></pre>"},{"location":"troubleshooting/#interpreting-multiple-conditions","title":"Interpreting Multiple Conditions","text":"<p>Healthy resource: <pre><code>Ready: True (Succeeded) - Policy synced to Vault\nSynced: True (Succeeded) - Policy synced successfully\n</code></pre></p> <p>Connection issue: <pre><code>Ready: False (ConnectionNotReady) - connection \"vault-primary\" not ready\nSynced: False (Failed) - cannot sync without connection\n</code></pre></p> <p>Conflict detected: <pre><code>Ready: False (Conflict) - policy already exists and is managed by other-ns/other-policy\nSynced: False (Conflict) - cannot sync due to conflict\n</code></pre></p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li> <p>Check the GitHub Issues: github.com/panteparak/vault-access-operator/issues</p> </li> <li> <p>Collect diagnostic information: <pre><code># Export all vault resources\nkubectl get vaultconnections,vaultclusterpolicies,vaultpolicies,vaultclusterroles,vaultroles \\\n  -A -o yaml &gt; vault-resources.yaml\n\n# Get operator logs\nkubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager \\\n  --since=1h &gt; operator-logs.txt\n\n# Get events\nkubectl get events -A --field-selector reason!=Normal &gt; events.txt\n</code></pre></p> </li> <li> <p>Open an issue with the diagnostic information (remove any sensitive data like tokens or secrets).</p> </li> </ol>"},{"location":"webhooks/","title":"Admission Webhooks","text":"<p>The Vault Access Operator includes validating admission webhooks that enforce security constraints and configuration correctness before resources are created or updated.</p>"},{"location":"webhooks/#overview","title":"Overview","text":"Resource Webhook Type Purpose VaultPolicy Validating Path syntax, capabilities, namespace boundary VaultClusterPolicy Validating Path syntax, capabilities VaultRole Validating Service account names, policy references VaultClusterRole Validating Service account refs, policy references"},{"location":"webhooks/#vaultpolicy-validation","title":"VaultPolicy Validation","text":""},{"location":"webhooks/#path-validation","title":"Path Validation","text":"<p>Paths must match the pattern: <code>^[a-zA-Z0-9/_*{}\\-+]+$</code></p> Character Allowed Example Letters Yes <code>secret/data/myapp</code> Numbers Yes <code>secret/data/v2/app</code> Slashes Yes <code>secret/data/namespace/key</code> Underscores Yes <code>secret/data/my_app</code> Asterisks Yes <code>secret/data/*</code> Curly braces Yes <code>secret/data/{{namespace}}</code> Hyphens Yes <code>secret/data/my-app</code> Plus signs Yes <code>pki/issue/internal+external</code> Spaces No <code>secret/data/my app</code> :x: Special chars No <code>secret/data/@app</code> :x:"},{"location":"webhooks/#capability-validation","title":"Capability Validation","text":"<p>Valid capabilities:</p> Capability Description <code>create</code> Create new data <code>read</code> Read existing data <code>update</code> Modify existing data <code>delete</code> Remove data <code>list</code> List keys/paths <code>sudo</code> Elevated privileges <code>deny</code> Explicitly deny access <p>Deny with Other Capabilities</p> <p>When <code>deny</code> is combined with other capabilities, a warning is issued because <code>deny</code> takes precedence and other capabilities are ignored.</p> <pre><code># Triggers a warning - other caps ignored\ncapabilities: [deny, read, list]\n</code></pre>"},{"location":"webhooks/#namespace-boundary-enforcement","title":"Namespace Boundary Enforcement","text":"<p>When <code>enforceNamespaceBoundary: true</code> is set on a VaultPolicy:</p> <ol> <li>All paths must contain <code>{{namespace}}</code> - Ensures policies are scoped to their namespace</li> <li>No wildcards before <code>{{namespace}}</code> - Prevents cross-namespace access</li> </ol>"},{"location":"webhooks/#valid-examples","title":"Valid Examples","text":"<pre><code>spec:\n  enforceNamespaceBoundary: true\n  rules:\n    # Good: namespace variable present\n    - path: \"secret/data/{{namespace}}/*\"\n      capabilities: [read, list]\n\n    # Good: namespace at the start\n    - path: \"{{namespace}}/secrets/*\"\n      capabilities: [read]\n\n    # Good: fixed prefix before namespace\n    - path: \"tenants/{{namespace}}/config\"\n      capabilities: [read]\n</code></pre>"},{"location":"webhooks/#invalid-examples","title":"Invalid Examples","text":"<pre><code>spec:\n  enforceNamespaceBoundary: true\n  rules:\n    # Bad: no {{namespace}} variable\n    - path: \"secret/data/shared/*\"\n      capabilities: [read]\n      # Error: path must contain {{namespace}}\n\n    # Bad: wildcard before namespace\n    - path: \"secret/data/*/{{namespace}}\"\n      capabilities: [read]\n      # Error: wildcard before {{namespace}} is a security risk\n\n    # Bad: wildcard prefix\n    - path: \"*/{{namespace}}/secrets\"\n      capabilities: [read]\n      # Error: could match any tenant's path\n</code></pre> <p>Security Risk: Wildcards Before Namespace</p> <p>A path like <code>secret/data/*/{{namespace}}</code> could allow access to:</p> <ul> <li><code>secret/data/other-tenant/my-namespace</code></li> <li><code>secret/data/admin/my-namespace</code></li> </ul> <p>This defeats the purpose of namespace isolation.</p>"},{"location":"webhooks/#vaultclusterpolicy-validation","title":"VaultClusterPolicy Validation","text":"<p>VaultClusterPolicy follows the same path and capability validation as VaultPolicy, but:</p> <ul> <li>No namespace boundary enforcement - Cluster policies are not namespace-scoped</li> <li>No <code>{{namespace}}</code> variable - Use <code>{{name}}</code> for the resource name if needed</li> </ul>"},{"location":"webhooks/#vaultrole-validation","title":"VaultRole Validation","text":""},{"location":"webhooks/#service-account-validation","title":"Service Account Validation","text":"<p>Service accounts must be simple names without namespace prefixes:</p> <pre><code># Valid\nserviceAccounts:\n  - default\n  - my-service-account\n  - api-server\n\n# Invalid - contains namespace prefix\nserviceAccounts:\n  - default/my-service-account  # Error!\n  - my-namespace/api-server     # Error!\n</code></pre> <p>Why Simple Names?</p> <p>VaultRole is namespace-scoped, so all service accounts are assumed to be in the same namespace as the VaultRole. The namespace is automatically applied when creating the Vault role.</p>"},{"location":"webhooks/#policy-reference-validation","title":"Policy Reference Validation","text":"Reference Kind Namespace Field Behavior <code>VaultPolicy</code> Optional Defaults to VaultRole's namespace <code>VaultPolicy</code> Specified Uses the specified namespace <code>VaultClusterPolicy</code> Must be empty Cluster-scoped, no namespace <pre><code>policies:\n  # VaultPolicy in same namespace (namespace defaults)\n  - kind: VaultPolicy\n    name: app-secrets\n\n  # VaultPolicy in different namespace (explicit)\n  - kind: VaultPolicy\n    name: shared-secrets\n    namespace: shared\n\n  # VaultClusterPolicy (no namespace allowed)\n  - kind: VaultClusterPolicy\n    name: global-reader\n    # namespace: xxx  # Error if specified!\n</code></pre>"},{"location":"webhooks/#vaultclusterrole-validation","title":"VaultClusterRole Validation","text":""},{"location":"webhooks/#service-account-validation_1","title":"Service Account Validation","text":"<p>Service accounts must include both name and namespace:</p> <pre><code># Valid\nserviceAccounts:\n  - name: platform-controller\n    namespace: platform-system\n  - name: monitoring-agent\n    namespace: monitoring\n\n# Invalid - missing fields\nserviceAccounts:\n  - name: my-sa\n    # namespace missing - Error!\n  - namespace: default\n    # name missing - Error!\n</code></pre>"},{"location":"webhooks/#policy-reference-validation_1","title":"Policy Reference Validation","text":"Reference Kind Namespace Field Behavior <code>VaultPolicy</code> Required Must specify namespace explicitly <code>VaultClusterPolicy</code> Must be empty Cluster-scoped, no namespace <pre><code>policies:\n  # VaultPolicy requires namespace in VaultClusterRole\n  - kind: VaultPolicy\n    name: app-secrets\n    namespace: production  # Required!\n\n  # VaultClusterPolicy (no namespace allowed)\n  - kind: VaultClusterPolicy\n    name: global-reader\n</code></pre>"},{"location":"webhooks/#webhook-configuration","title":"Webhook Configuration","text":""},{"location":"webhooks/#enabling-webhooks","title":"Enabling Webhooks","text":"<p>Webhooks are enabled by default when installing via Helm:</p> <pre><code>helm install vault-access-operator \\\n  oci://ghcr.io/panteparak/vault-access-operator/charts/vault-access-operator \\\n  --set webhooks.enabled=true\n</code></pre>"},{"location":"webhooks/#disabling-webhooks","title":"Disabling Webhooks","text":"<p>For development or testing environments:</p> <pre><code>helm install vault-access-operator \\\n  oci://ghcr.io/panteparak/vault-access-operator/charts/vault-access-operator \\\n  --set webhooks.enabled=false\n</code></pre> <p>Production Recommendation</p> <p>Always keep webhooks enabled in production to prevent invalid configurations from being applied.</p>"},{"location":"webhooks/#certificate-management","title":"Certificate Management","text":"<p>Webhooks require TLS certificates. Options:</p> cert-manager (Recommended)Self-signed <pre><code>webhooks:\n  certManager:\n    enabled: true\n    issuerRef:\n      name: selfsigned-issuer\n      kind: ClusterIssuer\n</code></pre> <pre><code>webhooks:\n  certManager:\n    enabled: false\n  selfSigned:\n    enabled: true\n</code></pre>"},{"location":"webhooks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"webhooks/#common-errors","title":"Common Errors","text":"<p>\"path contains invalid characters\"</p> <pre><code>Error: validation failed: rule[0]: path \"secret/data/my app\" contains invalid characters\n</code></pre> <p>Fix: Remove spaces and special characters from the path.</p> <p>\"path must contain {{namespace}}\"</p> <pre><code>Error: validation failed: rule[0]: path \"secret/data/*\" must contain {{namespace}} when namespace boundary enforcement is enabled\n</code></pre> <p>Fix: Add <code>{{namespace}}</code> to the path or disable <code>enforceNamespaceBoundary</code>.</p> <p>\"wildcard before {{namespace}} is a security risk\"</p> <pre><code>Error: validation failed: rule[0]: path \"*/{{namespace}}/secrets\" contains wildcard (*) before {{namespace}}\n</code></pre> <p>Fix: Move the wildcard after <code>{{namespace}}</code> or use a fixed prefix.</p> <p>\"must be a simple name without namespace prefix\"</p> <pre><code>Error: validation failed: serviceAccounts[0]: must be a simple name without namespace prefix (got \"default/my-sa\")\n</code></pre> <p>Fix: Use just the service account name without the namespace prefix.</p>"},{"location":"webhooks/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Detailed CRD documentation</li> <li>Examples - Configuration examples</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"auth-methods/","title":"Authentication Methods","text":"<p>The Vault Access Operator supports multiple authentication methods to connect to HashiCorp Vault. Choose the method that best fits your environment and security requirements.</p>"},{"location":"auth-methods/#quick-reference","title":"Quick Reference","text":"Method Best For Cloud Provider Complexity Kubernetes Standard K8s clusters Any Low AWS IAM EKS with IRSA AWS Medium GCP IAM GKE with Workload Identity GCP Medium OIDC EKS/GKE/Azure workload identity Any Medium JWT External identity providers Any Medium AppRole CI/CD pipelines Any Low Token Development/testing only Any Very Low Bootstrap Initial Vault setup Any Medium"},{"location":"auth-methods/#decision-guide","title":"Decision Guide","text":"<pre><code>flowchart TD\n    Q[\"What environment&lt;br/&gt;are you running in?\"]\n    Q --&gt; EKS[\"EKS\"]\n    Q --&gt; GKE[\"GKE\"]\n    Q --&gt; Other[\"Other\"]\n\n    EKS --&gt; IRSA{\"IRSA enabled?\"}\n    GKE --&gt; WI{\"Workload Identity?\"}\n    Other --&gt; K8s3[\"Kubernetes Auth\"]\n\n    IRSA -- Yes --&gt; AWS[\"AWS IAM\"]\n    IRSA -- No --&gt; K8s1[\"Kubernetes Auth\"]\n    WI -- Yes --&gt; GCP[\"GCP IAM\"]\n    WI -- No --&gt; K8s2[\"Kubernetes Auth\"]</code></pre>"},{"location":"auth-methods/#method-comparison","title":"Method Comparison","text":""},{"location":"auth-methods/#security-level","title":"Security Level","text":"Method Token Lifetime Credential Type Auto-Rotation Kubernetes Short (1h default) Service Account Token Yes AWS IAM Short IAM Credentials Yes (IRSA) GCP IAM Short Workload Identity Token Yes OIDC Short JWT from IdP Yes JWT Configurable External JWT Depends AppRole Configurable SecretID Manual Token Long-lived Static Token No Bootstrap One-time Bootstrap Token N/A"},{"location":"auth-methods/#prerequisites","title":"Prerequisites","text":"Method Vault Config Required K8s Config Required Cloud Config Required Kubernetes Kubernetes auth enabled ServiceAccount None AWS IAM AWS auth enabled IRSA annotation IAM Role + Trust Policy GCP IAM GCP auth enabled Workload Identity annotation GCP SA + IAM Binding OIDC OIDC auth enabled ServiceAccount OIDC Provider JWT JWT auth enabled ServiceAccount or Secret IdP configuration AppRole AppRole auth enabled Secret with credentials None Token None Secret with token None Bootstrap Permissive token Secret with token None"},{"location":"auth-methods/#which-method-should-i-use","title":"Which Method Should I Use?","text":""},{"location":"auth-methods/#production-workloads","title":"Production Workloads","text":"<ol> <li>EKS clusters: Use AWS IAM with IRSA for the strongest security</li> <li>GKE clusters: Use GCP IAM with Workload Identity</li> <li>Standard Kubernetes: Use Kubernetes auth - it's secure and well-tested</li> <li>Multi-cloud or hybrid: Use OIDC for consistent identity federation</li> </ol>"},{"location":"auth-methods/#cicd-pipelines","title":"CI/CD Pipelines","text":"<p>Use AppRole auth for:</p> <ul> <li>GitHub Actions</li> <li>GitLab CI</li> <li>Jenkins</li> <li>ArgoCD</li> </ul>"},{"location":"auth-methods/#development-and-testing","title":"Development and Testing","text":"<p>Use Token auth only for:</p> <ul> <li>Local development</li> <li>Quick testing</li> <li>Demos</li> </ul> <p>Never use Token auth in production</p> <p>Token auth uses long-lived static credentials and should never be used in production environments.</p>"},{"location":"auth-methods/#initial-setup","title":"Initial Setup","text":"<p>Use Bootstrap auth to:</p> <ul> <li>Configure Vault's Kubernetes auth method</li> <li>Set up initial policies</li> <li>Transition to Kubernetes auth afterward</li> </ul>"},{"location":"auth-methods/#common-configuration","title":"Common Configuration","text":"<p>All authentication methods share these common fields:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: my-vault\nspec:\n  address: https://vault.example.com:8200\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        key: ca.crt\n  auth:\n    # Choose ONE of the following auth methods\n    kubernetes: { ... }\n    aws: { ... }\n    gcp: { ... }\n    oidc: { ... }\n    jwt: { ... }\n    appRole: { ... }\n    token: { ... }\n    bootstrap: { ... }\n</code></pre>"},{"location":"auth-methods/#next-steps","title":"Next Steps","text":"<p>Choose your authentication method and follow the detailed setup guide:</p> <ul> <li>Kubernetes Authentication - Standard K8s clusters</li> <li>AWS IAM Authentication - EKS with IRSA</li> <li>GCP IAM Authentication - GKE with Workload Identity</li> <li>OIDC Authentication - Workload identity federation</li> <li>JWT Authentication - External identity providers</li> <li>AppRole Authentication - CI/CD pipelines</li> <li>Token Authentication - Development only</li> <li>Bootstrap Authentication - Initial setup</li> </ul>"},{"location":"auth-methods/approle/","title":"AppRole Authentication","text":"<p>AppRole authentication is designed for machine-to-machine authentication, making it ideal for CI/CD pipelines and automated systems.</p>"},{"location":"auth-methods/approle/#overview","title":"Overview","text":"<p>Best for: CI/CD pipelines (GitHub Actions, GitLab CI, Jenkins), automated deployments, non-Kubernetes workloads.</p> <p>How it works:</p> <ol> <li>The operator reads RoleID and SecretID from Kubernetes secrets</li> <li>Credentials are sent to Vault's AppRole auth endpoint</li> <li>Vault validates the credentials</li> <li>Vault returns a token with the configured policies</li> </ol> <pre><code>sequenceDiagram\n    participant S as K8s Secret&lt;br/&gt;(RoleID + SecretID)\n    participant Op as Operator\n    participant V as Vault\n\n    Op-&gt;&gt;S: 1. Read credentials\n    S--&gt;&gt;Op: RoleID + SecretID\n    Op-&gt;&gt;V: 2. Login\n    V--&gt;&gt;Op: 3. Vault Token\n    Note over Op: Authenticated</code></pre>"},{"location":"auth-methods/approle/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/approle/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>AppRole auth method enabled</li> </ul>"},{"location":"auth-methods/approle/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Secret containing RoleID</li> <li>Secret containing SecretID</li> </ul>"},{"location":"auth-methods/approle/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have <code>vault</code> CLI access to create AppRole credentials</li> <li>You can create Kubernetes secrets in the operator namespace</li> <li>You have a secure way to distribute the initial SecretID</li> </ul>"},{"location":"auth-methods/approle/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/approle/#step-1-enable-approle-auth-in-vault","title":"Step 1: Enable AppRole Auth in Vault","text":"<pre><code>vault auth enable approle\n</code></pre>"},{"location":"auth-methods/approle/#step-2-create-vault-policy","title":"Step 2: Create Vault Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/approle/#step-3-create-approle-in-vault","title":"Step 3: Create AppRole in Vault","text":"<pre><code># Create the AppRole\nvault write auth/approle/role/vault-access-operator \\\n    token_policies=\"vault-access-operator\" \\\n    token_ttl=1h \\\n    token_max_ttl=4h \\\n    secret_id_ttl=0 \\\n    secret_id_num_uses=0\n\n# Get the RoleID\nvault read auth/approle/role/vault-access-operator/role-id\n# role_id    db02de05-fa39-4855-059b-67221c5c2f63\n\n# Generate a SecretID\nvault write -f auth/approle/role/vault-access-operator/secret-id\n# secret_id             6a174c20-f6de-a53c-74d2-6018fcceff64\n# secret_id_accessor    c454f7e5-996e-7230-6074-6ef26b7bcf86\n</code></pre> Parameter Description <code>token_policies</code> Vault policies attached to tokens <code>token_ttl</code> Default token lifetime <code>token_max_ttl</code> Maximum token lifetime <code>secret_id_ttl</code> SecretID expiration (0 = never) <code>secret_id_num_uses</code> Max SecretID uses (0 = unlimited)"},{"location":"auth-methods/approle/#step-4-create-kubernetes-secrets","title":"Step 4: Create Kubernetes Secrets","text":"<pre><code># Create secret for RoleID\nkubectl create secret generic vault-approle-role-id \\\n    -n vault-access-operator-system \\\n    --from-literal=role-id=db02de05-fa39-4855-059b-67221c5c2f63\n\n# Create secret for SecretID\nkubectl create secret generic vault-approle-secret-id \\\n    -n vault-access-operator-system \\\n    --from-literal=secret-id=6a174c20-f6de-a53c-74d2-6018fcceff64\n</code></pre> <p>SecretID Security</p> <p>SecretID is a sensitive credential. Consider:</p> <ul> <li>Using short-lived SecretIDs with rotation</li> <li>Limiting SecretID uses</li> <li>Using External Secrets Operator to sync from Vault</li> </ul>"},{"location":"auth-methods/approle/#step-5-create-vaultconnection-resource","title":"Step 5: Create VaultConnection Resource","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-approle\nspec:\n  address: https://vault.example.com:8200\n\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  auth:\n    appRole:\n      roleId: db02de05-fa39-4855-059b-67221c5c2f63\n      secretIdRef:\n        name: vault-approle-secret-id\n        namespace: vault-access-operator-system\n        key: secret-id\n      # mountPath: approle  # default\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/approle/#step-6-verify-the-connection","title":"Step 6: Verify the Connection","text":"<pre><code>kubectl get vaultconnection vault-approle -o yaml\n</code></pre>"},{"location":"auth-methods/approle/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/approle/#required-fields","title":"Required Fields","text":"Field Description <code>auth.appRole.roleId</code> The AppRole RoleID <code>auth.appRole.secretIdRef</code> Reference to secret containing SecretID"},{"location":"auth-methods/approle/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>mountPath</code> <code>approle</code> Vault auth mount path"},{"location":"auth-methods/approle/#secretid-rotation","title":"SecretID Rotation","text":"<p>For production, implement SecretID rotation:</p>"},{"location":"auth-methods/approle/#option-1-wrapped-secretid","title":"Option 1: Wrapped SecretID","text":"<p>Generate a wrapped SecretID that can only be unwrapped once:</p> <pre><code>vault write -wrap-ttl=120s -f auth/approle/role/vault-access-operator/secret-id\n</code></pre>"},{"location":"auth-methods/approle/#option-2-external-secrets-operator","title":"Option 2: External Secrets Operator","text":"<p>Use External Secrets to sync SecretID from Vault:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: vault-approle-secret-id\n  namespace: vault-access-operator-system\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: vault\n    kind: ClusterSecretStore\n  target:\n    name: vault-approle-secret-id\n  data:\n    - secretKey: secret-id\n      remoteRef:\n        key: auth/approle/role/vault-access-operator/secret-id\n        property: secret_id\n</code></pre>"},{"location":"auth-methods/approle/#option-3-limited-use-secretid","title":"Option 3: Limited-Use SecretID","text":"<p>Create SecretIDs that expire after a set number of uses:</p> <pre><code>vault write auth/approle/role/vault-access-operator \\\n    secret_id_num_uses=10 \\\n    secret_id_ttl=24h\n</code></pre>"},{"location":"auth-methods/approle/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/approle/#invalid-role-or-secret-id-error","title":"\"invalid role or secret ID\" error","text":"<p>Symptoms: <pre><code>Error: invalid role or secret ID\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify the RoleID is correct:    <pre><code>vault read auth/approle/role/vault-access-operator/role-id\n</code></pre></p> </li> <li> <p>Check if the SecretID is valid:    <pre><code>vault write auth/approle/role/vault-access-operator/secret-id-accessor/lookup \\\n    secret_id_accessor=&lt;accessor&gt;\n</code></pre></p> </li> <li> <p>Verify the secret contents in Kubernetes:    <pre><code>kubectl get secret vault-approle-secret-id -n vault-access-operator-system -o jsonpath='{.data.secret-id}' | base64 -d\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/approle/#secretid-has-expired","title":"SecretID has expired","text":"<p>Symptoms: <pre><code>Error: secret ID is expired\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Generate a new SecretID:    <pre><code>vault write -f auth/approle/role/vault-access-operator/secret-id\n</code></pre></p> </li> <li> <p>Update the Kubernetes secret:    <pre><code>kubectl create secret generic vault-approle-secret-id \\\n    -n vault-access-operator-system \\\n    --from-literal=secret-id=&lt;new-secret-id&gt; \\\n    --dry-run=client -o yaml | kubectl apply -f -\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/approle/#cicd-integration-examples","title":"CI/CD Integration Examples","text":"GitHub ActionsGitLab CI <pre><code>jobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Get Vault Token\n        env:\n          VAULT_ADDR: https://vault.example.com:8200\n          VAULT_ROLE_ID: ${{ secrets.VAULT_ROLE_ID }}\n          VAULT_SECRET_ID: ${{ secrets.VAULT_SECRET_ID }}\n        run: |\n          VAULT_TOKEN=$(vault write -field=token auth/approle/login \\\n              role_id=$VAULT_ROLE_ID \\\n              secret_id=$VAULT_SECRET_ID)\n          echo \"VAULT_TOKEN=$VAULT_TOKEN\" &gt;&gt; $GITHUB_ENV\n</code></pre> <pre><code>variables:\n  VAULT_ADDR: https://vault.example.com:8200\n\nget_vault_token:\n  script:\n    - |\n      export VAULT_TOKEN=$(vault write -field=token auth/approle/login \\\n          role_id=$VAULT_ROLE_ID \\\n          secret_id=$VAULT_SECRET_ID)\n</code></pre>"},{"location":"auth-methods/approle/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Authentication - Better for K8s-native workloads</li> <li>Token Authentication - Simpler but less secure</li> <li>API Reference - Complete field reference</li> </ul>"},{"location":"auth-methods/aws-iam/","title":"AWS IAM Authentication","text":"<p>AWS IAM authentication enables EKS workloads to authenticate to Vault using IAM Roles for Service Accounts (IRSA). This is the recommended method for EKS clusters.</p>"},{"location":"auth-methods/aws-iam/#overview","title":"Overview","text":"<p>Best for: Amazon EKS clusters with IRSA configured.</p> <p>How it works:</p> <ol> <li>EKS injects AWS credentials into pods via IRSA</li> <li>The operator uses these credentials to sign an STS GetCallerIdentity request</li> <li>Vault verifies the signed request with AWS STS</li> <li>Vault returns a token with the configured policies</li> </ol> <pre><code>sequenceDiagram\n    participant IRSA as AWS STS (IRSA)\n    participant Op as Operator (EKS Pod)\n    participant V as Vault\n    participant STS as AWS STS\n\n    IRSA--&gt;&gt;Op: 1. Inject Token\n    Op-&gt;&gt;V: 2. Login with signed STS request\n    V-&gt;&gt;STS: 3. Verify with STS\n    STS--&gt;&gt;V: 4. Identity Valid\n    V--&gt;&gt;Op: 5. Return Vault Token\n    Note over Op: Authenticated</code></pre>"},{"location":"auth-methods/aws-iam/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/aws-iam/#aws-requirements","title":"AWS Requirements","text":"<ul> <li>EKS cluster with OIDC provider enabled</li> <li>IAM role with trust policy for the service account</li> <li>Permissions for sts:GetCallerIdentity (automatic with IRSA)</li> </ul>"},{"location":"auth-methods/aws-iam/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>AWS auth method enabled</li> <li>AWS credentials for Vault to verify requests (optional if using IAM role)</li> </ul>"},{"location":"auth-methods/aws-iam/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>EKS v1.25 or later</li> <li>Service account annotated for IRSA</li> </ul>"},{"location":"auth-methods/aws-iam/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have an EKS cluster with OIDC provider enabled</li> <li>You have AWS CLI configured with appropriate permissions</li> <li>You have <code>kubectl</code> access to your EKS cluster</li> <li>You have <code>vault</code> CLI access</li> </ul>"},{"location":"auth-methods/aws-iam/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/aws-iam/#step-1-get-eks-oidc-provider-url","title":"Step 1: Get EKS OIDC Provider URL","text":"<pre><code># Get your cluster's OIDC issuer URL\nOIDC_ISSUER=$(aws eks describe-cluster \\\n    --name my-cluster \\\n    --query \"cluster.identity.oidc.issuer\" \\\n    --output text)\n\necho $OIDC_ISSUER\n# Output: https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n\n# Extract the OIDC ID\nOIDC_ID=$(echo $OIDC_ISSUER | sed 's|https://||' | sed 's|/id/||')\n</code></pre>"},{"location":"auth-methods/aws-iam/#step-2-create-iam-role-for-the-operator","title":"Step 2: Create IAM Role for the Operator","text":"<p>Create a trust policy that allows the operator's service account to assume the role:</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"Federated\": \"arn:aws:iam::ACCOUNT_ID:oidc-provider/oidc.eks.REGION.amazonaws.com/id/CLUSTER_ID\"\n      },\n      \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"oidc.eks.REGION.amazonaws.com/id/CLUSTER_ID:sub\": \"system:serviceaccount:vault-access-operator-system:vault-access-operator-controller-manager\",\n          \"oidc.eks.REGION.amazonaws.com/id/CLUSTER_ID:aud\": \"sts.amazonaws.com\"\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>Create the IAM role:</p> <pre><code>aws iam create-role \\\n    --role-name vault-access-operator-role \\\n    --assume-role-policy-document file://trust-policy.json\n</code></pre> <p>No additional IAM permissions needed</p> <p>The role doesn't need any IAM permissions beyond the ability to be assumed. Vault only uses it to verify identity.</p>"},{"location":"auth-methods/aws-iam/#step-3-annotate-the-operator-service-account","title":"Step 3: Annotate the Operator Service Account","text":"<pre><code>kubectl annotate serviceaccount \\\n    vault-access-operator-controller-manager \\\n    -n vault-access-operator-system \\\n    eks.amazonaws.com/role-arn=arn:aws:iam::ACCOUNT_ID:role/vault-access-operator-role\n</code></pre> <p>Or via Helm values:</p> <pre><code>serviceAccount:\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/vault-access-operator-role\n</code></pre>"},{"location":"auth-methods/aws-iam/#step-4-enable-aws-auth-in-vault","title":"Step 4: Enable AWS Auth in Vault","text":"<pre><code># Enable AWS auth method\nvault auth enable aws\n\n# Configure with IAM credentials (optional, Vault can use its own IAM role)\nvault write auth/aws/config/client \\\n    access_key=$AWS_ACCESS_KEY_ID \\\n    secret_key=$AWS_SECRET_ACCESS_KEY\n</code></pre> <p>Vault with IAM Role</p> <p>If Vault runs with an IAM role (EC2, EKS, or Lambda), you can skip providing credentials: <pre><code>vault write auth/aws/config/client iam_server_id_header_value=\"vault.example.com\"\n</code></pre></p>"},{"location":"auth-methods/aws-iam/#step-5-create-vault-policy","title":"Step 5: Create Vault Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\n# Manage ACL policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# Manage Kubernetes auth roles\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/aws-iam/#step-6-create-vault-role-for-aws-auth","title":"Step 6: Create Vault Role for AWS Auth","text":"<pre><code>vault write auth/aws/role/vault-access-operator \\\n    auth_type=iam \\\n    bound_iam_principal_arn=\"arn:aws:iam::ACCOUNT_ID:role/vault-access-operator-role\" \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre> Parameter Description <code>auth_type</code> Use <code>iam</code> for IRSA authentication <code>bound_iam_principal_arn</code> The IAM role ARN allowed to authenticate <code>policies</code> Vault policies to attach <code>ttl</code> Token lifetime"},{"location":"auth-methods/aws-iam/#step-7-create-vaultconnection-resource","title":"Step 7: Create VaultConnection Resource","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-aws\nspec:\n  address: https://vault.example.com:8200\n\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  auth:\n    aws:\n      role: vault-access-operator\n      authType: iam\n      # Optional fields\n      # region: us-west-2            # Auto-detected from environment\n      # stsEndpoint: https://...     # Custom STS endpoint (VPC endpoints)\n      # iamServerIdHeaderValue: ...  # Extra security header\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/aws-iam/#step-8-verify-the-connection","title":"Step 8: Verify the Connection","text":"<pre><code># Check VaultConnection status\nkubectl get vaultconnection vault-aws -o yaml\n\n# Expected status\n# status:\n#   phase: Active\n#   healthy: true\n</code></pre>"},{"location":"auth-methods/aws-iam/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/aws-iam/#required-fields","title":"Required Fields","text":"Field Description <code>auth.aws.role</code> The Vault role name to authenticate as"},{"location":"auth-methods/aws-iam/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>authPath</code> <code>aws</code> Vault auth mount path <code>authType</code> <code>iam</code> Auth type: <code>iam</code> or <code>ec2</code> <code>region</code> Auto-detected AWS region for STS calls <code>stsEndpoint</code> AWS default Custom STS endpoint URL <code>iamServerIdHeaderValue</code> None X-Vault-AWS-IAM-Server-ID header value"},{"location":"auth-methods/aws-iam/#iam-server-id-header","title":"IAM Server ID Header","text":"<p>For additional security, configure an IAM server ID header:</p> <pre><code>auth:\n  aws:\n    role: vault-access-operator\n    iamServerIdHeaderValue: vault.example.com\n</code></pre> <p>This must match the <code>iam_server_id_header_value</code> in Vault's AWS auth config:</p> <pre><code>vault write auth/aws/config/client iam_server_id_header_value=\"vault.example.com\"\n</code></pre>"},{"location":"auth-methods/aws-iam/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/aws-iam/#no-credentials-found-error","title":"\"no credentials found\" error","text":"<p>Symptoms: <pre><code>Error: NoCredentialProviders: no valid providers in chain\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify IRSA is configured correctly:    <pre><code>kubectl describe sa vault-access-operator-controller-manager -n vault-access-operator-system | grep eks.amazonaws.com/role-arn\n</code></pre></p> </li> <li> <p>Check the pod has the AWS token file:    <pre><code>kubectl exec -n vault-access-operator-system deploy/vault-access-operator-controller-manager -- ls -la /var/run/secrets/eks.amazonaws.com/serviceaccount/\n</code></pre></p> </li> <li> <p>Verify the trust policy allows the service account</p> </li> </ol>"},{"location":"auth-methods/aws-iam/#access-denied-from-vault","title":"\"access denied\" from Vault","text":"<p>Symptoms: <pre><code>Error: entry for role vault-access-operator not found\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify the Vault role exists:    <pre><code>vault read auth/aws/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Check the bound_iam_principal_arn matches your IAM role ARN exactly</p> </li> </ol>"},{"location":"auth-methods/aws-iam/#sts-endpoint-connectivity-issues","title":"STS endpoint connectivity issues","text":"<p>Symptoms: <pre><code>Error: RequestError: send request failed\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>For VPC endpoints, specify the STS endpoint:    <pre><code>auth:\n  aws:\n    stsEndpoint: https://sts.us-west-2.amazonaws.com\n</code></pre></p> </li> <li> <p>Ensure the pod has network access to STS</p> </li> </ol>"},{"location":"auth-methods/aws-iam/#example-complete-setup-with-terraform","title":"Example: Complete Setup with Terraform","text":"IAM Role (Terraform)VaultConnection <pre><code>data \"aws_eks_cluster\" \"cluster\" {\n  name = \"my-cluster\"\n}\n\nresource \"aws_iam_role\" \"vault_operator\" {\n  name = \"vault-access-operator-role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Effect = \"Allow\"\n      Principal = {\n        Federated = \"arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${replace(data.aws_eks_cluster.cluster.identity[0].oidc[0].issuer, \"https://\", \"\")}\"\n      }\n      Action = \"sts:AssumeRoleWithWebIdentity\"\n      Condition = {\n        StringEquals = {\n          \"${replace(data.aws_eks_cluster.cluster.identity[0].oidc[0].issuer, \"https://\", \"\")}:sub\" = \"system:serviceaccount:vault-access-operator-system:vault-access-operator-controller-manager\"\n        }\n      }\n    }]\n  })\n}\n</code></pre> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-aws\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    aws:\n      role: vault-access-operator\n      authType: iam\n</code></pre>"},{"location":"auth-methods/aws-iam/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Authentication - Alternative for non-EKS clusters</li> <li>OIDC Authentication - Alternative using EKS OIDC directly</li> <li>API Reference - Complete field reference</li> </ul>"},{"location":"auth-methods/bootstrap/","title":"Bootstrap Authentication","text":"<p>Bootstrap authentication is used for initial Vault setup when the Kubernetes auth method hasn't been configured yet. It uses a one-time token to configure Vault and then transitions to Kubernetes auth.</p>"},{"location":"auth-methods/bootstrap/#overview","title":"Overview","text":"<p>Best for: Initial Vault configuration, setting up Kubernetes auth method.</p> <p>How it works:</p> <ol> <li>Operator uses a bootstrap token to authenticate to Vault</li> <li>Operator configures Vault's Kubernetes auth method</li> <li>Operator transitions to Kubernetes auth</li> <li>Bootstrap token is optionally revoked</li> </ol> <pre><code>sequenceDiagram\n    participant BT as Bootstrap Token\n    participant Op as Operator\n    participant V as Vault\n    participant K8s as K8s Auth Method\n\n    rect rgb(255, 245, 235)\n        Note over BT,V: Phase 1: Bootstrap\n        Op-&gt;&gt;BT: Read token\n        BT--&gt;&gt;Op: Bootstrap token\n        Op-&gt;&gt;V: Authenticate\n        V--&gt;&gt;Op: Access granted\n        Op-&gt;&gt;V: Configure K8s auth method\n    end\n\n    rect rgb(235, 245, 255)\n        Note over Op,K8s: Phase 2: Operational\n        Op-&gt;&gt;V: Authenticate via K8s auth\n        V-&gt;&gt;K8s: Validate\n        K8s--&gt;&gt;V: Valid\n        V--&gt;&gt;Op: Vault Token\n    end\n\n    Op-&gt;&gt;V: Auto-revoke bootstrap token\n    Note over Op: Normal Operation</code></pre>"},{"location":"auth-methods/bootstrap/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/bootstrap/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>Bootstrap token with permissions to configure auth methods</li> </ul>"},{"location":"auth-methods/bootstrap/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Kubernetes v1.25 or later</li> <li>Kubernetes API server accessible from Vault</li> </ul>"},{"location":"auth-methods/bootstrap/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You're setting up Vault Access Operator for the first time</li> <li>Vault's Kubernetes auth method is NOT yet configured</li> <li>You have a Vault token with sufficient permissions</li> <li>This is a one-time setup process</li> </ul>"},{"location":"auth-methods/bootstrap/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/bootstrap/#step-1-create-bootstrap-token-in-vault","title":"Step 1: Create Bootstrap Token in Vault","text":"<p>The bootstrap token needs permissions to: - Enable and configure the Kubernetes auth method - Create policies - Create auth roles</p> <pre><code># Create a bootstrap policy\nvault policy write bootstrap-operator - &lt;&lt;EOF\n# Enable auth methods\npath \"sys/auth/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"sudo\"]\n}\n\n# Configure auth methods\npath \"auth/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\n\n# Manage policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\nEOF\n\n# Create a token with the bootstrap policy\nvault token create \\\n    -policy=bootstrap-operator \\\n    -ttl=1h \\\n    -use-limit=10 \\\n    -display-name=\"vault-access-operator-bootstrap\"\n\n# Output:\n# token            hvs.CAESI...\n# token_accessor   ...\n</code></pre> <p>Security Considerations</p> <ul> <li>Use a short TTL (1 hour or less)</li> <li>Limit the number of uses</li> <li>Revoke the token immediately after setup</li> </ul>"},{"location":"auth-methods/bootstrap/#step-2-create-kubernetes-secret-for-bootstrap-token","title":"Step 2: Create Kubernetes Secret for Bootstrap Token","text":"<pre><code>kubectl create secret generic vault-bootstrap-token \\\n    -n vault-access-operator-system \\\n    --from-literal=token=hvs.CAESI...\n</code></pre>"},{"location":"auth-methods/bootstrap/#step-3-create-vaultconnection-with-bootstrap-auth","title":"Step 3: Create VaultConnection with Bootstrap Auth","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  auth:\n    # Bootstrap phase - will auto-transition to kubernetes auth\n    bootstrap:\n      secretRef:\n        name: vault-bootstrap-token\n        namespace: vault-access-operator-system\n        key: token\n      autoRevoke: true  # Revoke bootstrap token after setup\n\n    # Target configuration - operator will set this up\n    kubernetes:\n      role: vault-access-operator\n      authPath: kubernetes\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/bootstrap/#step-4-monitor-the-bootstrap-process","title":"Step 4: Monitor the Bootstrap Process","text":"<pre><code># Watch the VaultConnection status\nkubectl get vaultconnection vault-primary -w\n\n# Check operator logs for bootstrap progress\nkubectl logs -n vault-access-operator-system \\\n    deploy/vault-access-operator-controller-manager -f\n</code></pre> <p>Expected progression: 1. <code>Phase: Pending</code> - Starting bootstrap 2. <code>Phase: Syncing</code> - Configuring Vault 3. <code>Phase: Active</code> - Bootstrap complete, using Kubernetes auth</p>"},{"location":"auth-methods/bootstrap/#step-5-verify-configuration","title":"Step 5: Verify Configuration","text":"<p>After bootstrap completes:</p> <pre><code># Verify Kubernetes auth is enabled\nvault auth list | grep kubernetes\n\n# Verify the operator role exists\nvault read auth/kubernetes/role/vault-access-operator\n\n# Verify the bootstrap token is revoked (if autoRevoke=true)\nvault token lookup hvs.CAESI...  # Should fail\n</code></pre>"},{"location":"auth-methods/bootstrap/#step-6-clean-up-bootstrap-secret","title":"Step 6: Clean Up Bootstrap Secret","text":"<pre><code># Delete the bootstrap secret (no longer needed)\nkubectl delete secret vault-bootstrap-token -n vault-access-operator-system\n</code></pre>"},{"location":"auth-methods/bootstrap/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/bootstrap/#required-fields","title":"Required Fields","text":"Field Description <code>auth.bootstrap.secretRef</code> Reference to secret containing bootstrap token"},{"location":"auth-methods/bootstrap/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>autoRevoke</code> <code>true</code> Revoke bootstrap token after successful setup"},{"location":"auth-methods/bootstrap/#what-gets-configured","title":"What Gets Configured","text":"<p>During bootstrap, the operator:</p> <ol> <li> <p>Enables Kubernetes auth (if not already enabled)    <pre><code>vault auth enable kubernetes\n</code></pre></p> </li> <li> <p>Configures Kubernetes auth with cluster details    <pre><code>vault write auth/kubernetes/config \\\n    kubernetes_host=\"https://kubernetes.default.svc\" \\\n    kubernetes_ca_cert=\"@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt\"\n</code></pre></p> </li> <li> <p>Creates the operator policy <pre><code>path \"sys/policies/acl/*\" { capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"] }\npath \"auth/kubernetes/role/*\" { capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"] }\n</code></pre></p> </li> <li> <p>Creates the operator role <pre><code>vault write auth/kubernetes/role/vault-access-operator \\\n    bound_service_account_names=vault-access-operator-controller-manager \\\n    bound_service_account_namespaces=vault-access-operator-system \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre></p> </li> <li> <p>Transitions to Kubernetes auth</p> </li> <li>Revokes bootstrap token (if autoRevoke=true)</li> </ol>"},{"location":"auth-methods/bootstrap/#external-vault-setup","title":"External Vault Setup","text":"<p>When Vault runs outside the Kubernetes cluster, provide the external API server address:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    bootstrap:\n      secretRef:\n        name: vault-bootstrap-token\n        namespace: vault-access-operator-system\n        key: token\n    kubernetes:\n      role: vault-access-operator\n      kubernetesHost: https://k8s-api.example.com:6443  # External API address\n</code></pre>"},{"location":"auth-methods/bootstrap/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/bootstrap/#bootstrap-token-lacks-permissions","title":"Bootstrap token lacks permissions","text":"<p>Symptoms: <pre><code>Error: permission denied\n</code></pre></p> <p>Solutions:</p> <ol> <li>Verify the bootstrap policy has required permissions</li> <li>Check the token has the policy attached:    <pre><code>vault token lookup hvs.CAESI...\n</code></pre></li> </ol>"},{"location":"auth-methods/bootstrap/#kubernetes-auth-configuration-fails","title":"Kubernetes auth configuration fails","text":"<p>Symptoms: <pre><code>Error: error configuring Kubernetes auth\n</code></pre></p> <p>Solutions:</p> <ol> <li>Verify Vault can reach the Kubernetes API server</li> <li>Check the CA certificate is correct</li> <li>For external Vault, provide the correct <code>kubernetesHost</code></li> </ol>"},{"location":"auth-methods/bootstrap/#bootstrap-doesnt-transition-to-kubernetes-auth","title":"Bootstrap doesn't transition to Kubernetes auth","text":"<p>Symptoms: VaultConnection stays in bootstrap mode</p> <p>Solutions:</p> <ol> <li> <p>Check operator logs for errors:    <pre><code>kubectl logs -n vault-access-operator-system \\\n    deploy/vault-access-operator-controller-manager\n</code></pre></p> </li> <li> <p>Verify the Kubernetes auth role was created:    <pre><code>vault read auth/kubernetes/role/vault-access-operator\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/bootstrap/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Authentication - Post-bootstrap authentication</li> <li>Getting Started - Complete setup guide</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"auth-methods/gcp-iam/","title":"GCP IAM Authentication","text":"<p>GCP IAM authentication enables GKE workloads to authenticate to Vault using Workload Identity. This is the recommended method for GKE clusters.</p>"},{"location":"auth-methods/gcp-iam/#overview","title":"Overview","text":"<p>Best for: Google Kubernetes Engine (GKE) clusters with Workload Identity enabled.</p> <p>How it works:</p> <ol> <li>GKE Workload Identity maps Kubernetes service accounts to GCP service accounts</li> <li>The operator obtains a signed JWT from the GCP IAM Credentials API</li> <li>Vault verifies the JWT with GCP</li> <li>Vault returns a token with the configured policies</li> </ol> <pre><code>sequenceDiagram\n    participant Op as Operator (GKE Pod)\n    participant GCPC as GCP IAM Credentials API\n    participant V as Vault\n    participant GCP as GCP IAM\n\n    Op-&gt;&gt;GCPC: 1. Get JWT\n    GCPC--&gt;&gt;Op: 2. Signed JWT\n    Op-&gt;&gt;V: 3. Login with JWT\n    V-&gt;&gt;GCP: 4. Verify JWT\n    GCP--&gt;&gt;V: 5. Valid\n    V--&gt;&gt;Op: 6. Return Vault Token\n    Note over Op: Authenticated</code></pre>"},{"location":"auth-methods/gcp-iam/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/gcp-iam/#gcp-requirements","title":"GCP Requirements","text":"<ul> <li>GKE cluster with Workload Identity enabled</li> <li>GCP service account</li> <li>IAM binding between K8s SA and GCP SA</li> </ul>"},{"location":"auth-methods/gcp-iam/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>GCP auth method enabled</li> </ul>"},{"location":"auth-methods/gcp-iam/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>GKE v1.25 or later</li> <li>Service account annotated for Workload Identity</li> </ul>"},{"location":"auth-methods/gcp-iam/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have a GKE cluster with Workload Identity enabled</li> <li>You have <code>gcloud</code> CLI configured with appropriate permissions</li> <li>You have <code>kubectl</code> access to your GKE cluster</li> <li>You have <code>vault</code> CLI access</li> </ul>"},{"location":"auth-methods/gcp-iam/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/gcp-iam/#step-1-create-gcp-service-account","title":"Step 1: Create GCP Service Account","text":"<pre><code># Set variables\nPROJECT_ID=my-project\nGCP_SA_NAME=vault-access-operator\nK8S_NAMESPACE=vault-access-operator-system\nK8S_SA_NAME=vault-access-operator-controller-manager\n\n# Create GCP service account\ngcloud iam service-accounts create $GCP_SA_NAME \\\n    --project=$PROJECT_ID \\\n    --display-name=\"Vault Access Operator\"\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-2-configure-workload-identity","title":"Step 2: Configure Workload Identity","text":"<pre><code># Allow the K8s SA to impersonate the GCP SA\ngcloud iam service-accounts add-iam-policy-binding \\\n    $GCP_SA_NAME@$PROJECT_ID.iam.gserviceaccount.com \\\n    --project=$PROJECT_ID \\\n    --role=roles/iam.workloadIdentityUser \\\n    --member=\"serviceAccount:$PROJECT_ID.svc.id.goog[$K8S_NAMESPACE/$K8S_SA_NAME]\"\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-3-annotate-the-kubernetes-service-account","title":"Step 3: Annotate the Kubernetes Service Account","text":"<pre><code>kubectl annotate serviceaccount \\\n    $K8S_SA_NAME \\\n    -n $K8S_NAMESPACE \\\n    iam.gke.io/gcp-service-account=$GCP_SA_NAME@$PROJECT_ID.iam.gserviceaccount.com\n</code></pre> <p>Or via Helm values:</p> <pre><code>serviceAccount:\n  annotations:\n    iam.gke.io/gcp-service-account: vault-access-operator@my-project.iam.gserviceaccount.com\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-4-enable-gcp-auth-in-vault","title":"Step 4: Enable GCP Auth in Vault","text":"<pre><code># Enable GCP auth method\nvault auth enable gcp\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-5-create-vault-policy","title":"Step 5: Create Vault Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\n# Manage ACL policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# Manage Kubernetes auth roles\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-6-create-vault-role-for-gcp-auth","title":"Step 6: Create Vault Role for GCP Auth","text":"<pre><code>vault write auth/gcp/role/vault-access-operator \\\n    type=iam \\\n    bound_service_accounts=\"$GCP_SA_NAME@$PROJECT_ID.iam.gserviceaccount.com\" \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre> Parameter Description <code>type</code> Use <code>iam</code> for Workload Identity <code>bound_service_accounts</code> GCP service account email(s) allowed to authenticate <code>policies</code> Vault policies to attach <code>ttl</code> Token lifetime"},{"location":"auth-methods/gcp-iam/#step-7-create-vaultconnection-resource","title":"Step 7: Create VaultConnection Resource","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-gcp\nspec:\n  address: https://vault.example.com:8200\n\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  auth:\n    gcp:\n      role: vault-access-operator\n      authType: iam\n      serviceAccountEmail: vault-access-operator@my-project.iam.gserviceaccount.com\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/gcp-iam/#step-8-verify-the-connection","title":"Step 8: Verify the Connection","text":"<pre><code># Check VaultConnection status\nkubectl get vaultconnection vault-gcp -o yaml\n\n# Expected status\n# status:\n#   phase: Active\n#   healthy: true\n</code></pre>"},{"location":"auth-methods/gcp-iam/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/gcp-iam/#required-fields","title":"Required Fields","text":"Field Description <code>auth.gcp.role</code> The Vault role name to authenticate as"},{"location":"auth-methods/gcp-iam/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>authPath</code> <code>gcp</code> Vault auth mount path <code>authType</code> <code>iam</code> Auth type: <code>iam</code> or <code>gce</code> <code>serviceAccountEmail</code> Auto-detected GCP service account email <code>credentialsSecretRef</code> None Secret with GCP credentials JSON"},{"location":"auth-methods/gcp-iam/#auth-types","title":"Auth Types","text":"Type Description Use Case <code>iam</code> Uses IAM credentials to sign JWTs GKE with Workload Identity <code>gce</code> Uses GCE instance metadata Compute Engine VMs"},{"location":"auth-methods/gcp-iam/#using-explicit-credentials","title":"Using Explicit Credentials","text":"<p>If Workload Identity is not available, you can provide explicit GCP credentials:</p> <pre><code>auth:\n  gcp:\n    role: vault-access-operator\n    authType: iam\n    serviceAccountEmail: vault-access-operator@my-project.iam.gserviceaccount.com\n    credentialsSecretRef:\n      name: gcp-credentials\n      namespace: vault-access-operator-system\n      key: credentials.json\n</code></pre> <p>Create the secret:</p> <pre><code>kubectl create secret generic gcp-credentials \\\n    -n vault-access-operator-system \\\n    --from-file=credentials.json=/path/to/service-account.json\n</code></pre> <p>Prefer Workload Identity</p> <p>Using static credentials is less secure than Workload Identity. Only use this approach when Workload Identity is not available.</p>"},{"location":"auth-methods/gcp-iam/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/gcp-iam/#could-not-find-default-credentials-error","title":"\"could not find default credentials\" error","text":"<p>Symptoms: <pre><code>Error: google: could not find default credentials\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Workload Identity is configured:    <pre><code>kubectl describe sa vault-access-operator-controller-manager -n vault-access-operator-system | grep iam.gke.io\n</code></pre></p> </li> <li> <p>Check the GCP SA IAM binding:    <pre><code>gcloud iam service-accounts get-iam-policy \\\n    vault-access-operator@my-project.iam.gserviceaccount.com\n</code></pre></p> </li> <li> <p>Verify the node pool has Workload Identity enabled:    <pre><code>gcloud container node-pools describe default-pool \\\n    --cluster my-cluster \\\n    --zone us-central1-a \\\n    --format=\"value(config.workloadMetadataConfig)\"\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/gcp-iam/#permission-denied-from-vault","title":"\"permission denied\" from Vault","text":"<p>Symptoms: <pre><code>Error: permission denied\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify the Vault role exists:    <pre><code>vault read auth/gcp/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Check bound_service_accounts matches your GCP SA email exactly</p> </li> <li> <p>Verify the GCP SA has the right IAM permissions:    <pre><code># GCP SA needs to be able to sign JWTs (automatic with Workload Identity)\ngcloud iam service-accounts get-iam-policy \\\n    vault-access-operator@my-project.iam.gserviceaccount.com\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/gcp-iam/#metadata-server-connectivity-issues","title":"Metadata server connectivity issues","text":"<p>Symptoms: <pre><code>Error: metadata: GCE metadata not available\n</code></pre></p> <p>Solutions:</p> <ol> <li>Ensure Workload Identity is enabled on the cluster</li> <li>Verify the node pool has the correct metadata configuration</li> <li>Check network policies allow metadata server access</li> </ol>"},{"location":"auth-methods/gcp-iam/#example-complete-setup-with-terraform","title":"Example: Complete Setup with Terraform","text":"GCP Resources (Terraform)VaultConnection <pre><code>resource \"google_service_account\" \"vault_operator\" {\n  project      = var.project_id\n  account_id   = \"vault-access-operator\"\n  display_name = \"Vault Access Operator\"\n}\n\nresource \"google_service_account_iam_binding\" \"workload_identity\" {\n  service_account_id = google_service_account.vault_operator.name\n  role               = \"roles/iam.workloadIdentityUser\"\n  members = [\n    \"serviceAccount:${var.project_id}.svc.id.goog[vault-access-operator-system/vault-access-operator-controller-manager]\"\n  ]\n}\n</code></pre> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-gcp\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    gcp:\n      role: vault-access-operator\n      authType: iam\n      serviceAccountEmail: vault-access-operator@my-project.iam.gserviceaccount.com\n</code></pre>"},{"location":"auth-methods/gcp-iam/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Authentication - Alternative for any cluster</li> <li>OIDC Authentication - Alternative using GKE OIDC</li> <li>API Reference - Complete field reference</li> </ul>"},{"location":"auth-methods/jwt/","title":"JWT Authentication","text":"<p>JWT (JSON Web Token) authentication enables workloads to authenticate to Vault using JWTs from any identity provider. This is the most flexible authentication method for external identity systems.</p>"},{"location":"auth-methods/jwt/#overview","title":"Overview","text":"<p>Best for: External identity providers, custom identity systems, or when OIDC discovery isn't available.</p> <p>How it works:</p> <ol> <li>The operator obtains a JWT (from K8s SA token or external secret)</li> <li>The JWT is sent to Vault's JWT auth endpoint</li> <li>Vault validates the JWT signature against configured keys</li> <li>Vault returns a token with the configured policies</li> </ol>"},{"location":"auth-methods/jwt/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/jwt/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>JWT auth method enabled</li> <li>JWKS URI or public keys configured</li> </ul>"},{"location":"auth-methods/jwt/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Kubernetes v1.25 or later</li> <li>ServiceAccount for the operator (if using SA tokens)</li> </ul>"},{"location":"auth-methods/jwt/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have access to JWT signing keys or JWKS endpoint</li> <li>You have <code>kubectl</code> and <code>vault</code> CLI access</li> <li>You understand your identity provider's JWT format</li> </ul>"},{"location":"auth-methods/jwt/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/jwt/#step-1-enable-jwt-auth-in-vault","title":"Step 1: Enable JWT Auth in Vault","text":"<pre><code>vault auth enable jwt\n</code></pre>"},{"location":"auth-methods/jwt/#step-2-configure-jwt-validation","title":"Step 2: Configure JWT Validation","text":"Using JWKS URIUsing OIDC DiscoveryUsing Public Key <pre><code>vault write auth/jwt/config \\\n    jwks_url=\"https://your-idp.example.com/.well-known/jwks.json\" \\\n    default_role=\"vault-access-operator\"\n</code></pre> <pre><code>vault write auth/jwt/config \\\n    oidc_discovery_url=\"https://your-idp.example.com\" \\\n    default_role=\"vault-access-operator\"\n</code></pre> <pre><code>vault write auth/jwt/config \\\n    jwt_validation_pubkeys=\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...\n-----END PUBLIC KEY-----\" \\\n    default_role=\"vault-access-operator\"\n</code></pre>"},{"location":"auth-methods/jwt/#step-3-create-vault-policy","title":"Step 3: Create Vault Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/jwt/#step-4-create-vault-role","title":"Step 4: Create Vault Role","text":"<pre><code>vault write auth/jwt/role/vault-access-operator \\\n    role_type=\"jwt\" \\\n    bound_audiences=\"vault\" \\\n    bound_subject=\"system:serviceaccount:vault-access-operator-system:vault-access-operator-controller-manager\" \\\n    user_claim=\"sub\" \\\n    policies=\"vault-access-operator\" \\\n    ttl=\"1h\"\n</code></pre> Parameter Description <code>role_type</code> Always <code>jwt</code> for JWT auth <code>bound_audiences</code> Required audience claim(s) <code>bound_subject</code> Required subject claim (optional) <code>user_claim</code> Claim to use as entity alias <code>policies</code> Vault policies to attach"},{"location":"auth-methods/jwt/#step-5-create-vaultconnection-resource","title":"Step 5: Create VaultConnection Resource","text":"Using SA TokenUsing External JWT <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-jwt\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    jwt:\n      role: vault-access-operator\n      authPath: jwt\n      audiences:\n        - vault\n      tokenDuration: 1h\n      # No jwtSecretRef means use SA token\n</code></pre> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-jwt\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    jwt:\n      role: vault-access-operator\n      authPath: jwt\n      jwtSecretRef:\n        name: external-jwt\n        namespace: vault-access-operator-system\n        key: token\n</code></pre>"},{"location":"auth-methods/jwt/#step-6-verify-the-connection","title":"Step 6: Verify the Connection","text":"<pre><code>kubectl get vaultconnection vault-jwt -o yaml\n</code></pre>"},{"location":"auth-methods/jwt/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/jwt/#required-fields","title":"Required Fields","text":"Field Description <code>auth.jwt.role</code> The Vault role name to authenticate as"},{"location":"auth-methods/jwt/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>authPath</code> <code>jwt</code> Vault auth mount path <code>jwtSecretRef</code> None Secret containing external JWT <code>audiences</code> <code>[\"vault\"]</code> Audience claim(s) for SA token <code>tokenDuration</code> <code>1h</code> SA token lifetime <code>expectedIssuer</code> None Expected issuer claim (for validation) <code>expectedAudience</code> None Expected audience (for validation) <code>userClaim</code> None Claim for entity alias <code>groupsClaim</code> None Claim for group membership <code>claimsToPass</code> None Claims to include in token metadata"},{"location":"auth-methods/jwt/#claims-passthrough","title":"Claims Passthrough","text":"<p>Pass JWT claims to Vault for identity templating:</p> <pre><code>auth:\n  jwt:\n    role: vault-access-operator\n    claimsToPass:\n      - email\n      - groups\n      - team\n</code></pre> <p>This enables policies like:</p> <pre><code>path \"secret/data/{{identity.entity.aliases.jwt.metadata.team}}/*\" {\n  capabilities = [\"read\"]\n}\n</code></pre>"},{"location":"auth-methods/jwt/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/jwt/#signature-verification-failed-error","title":"\"signature verification failed\" error","text":"<p>Symptoms: <pre><code>Error: error validating token: signature verification failed\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify JWKS URL is accessible from Vault:    <pre><code>curl -s https://your-idp.example.com/.well-known/jwks.json\n</code></pre></p> </li> <li> <p>Check the JWT is signed with a key known to Vault:    <pre><code>vault read auth/jwt/config\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/jwt/#claim-not-found-error","title":"\"claim not found\" error","text":"<p>Symptoms: <pre><code>Error: claim \"sub\" not found in token\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Decode your JWT and verify claims:    <pre><code>echo \"$JWT\" | jwt decode -\n</code></pre></p> </li> <li> <p>Ensure the user_claim exists in your tokens</p> </li> </ol>"},{"location":"auth-methods/jwt/#audience-mismatch-error","title":"\"audience mismatch\" error","text":"<p>Solutions:</p> <ol> <li>Check bound_audiences in Vault role matches your token's aud claim</li> <li>For SA tokens, ensure audiences field in VaultConnection matches</li> </ol>"},{"location":"auth-methods/jwt/#see-also","title":"See Also","text":"<ul> <li>OIDC Authentication - When OIDC discovery is available</li> <li>Kubernetes Authentication - Simpler for K8s workloads</li> <li>API Reference - Complete field reference</li> </ul>"},{"location":"auth-methods/kubernetes/","title":"Kubernetes Authentication","text":"<p>Kubernetes authentication is the standard method for authenticating workloads running in Kubernetes clusters to HashiCorp Vault. It uses Kubernetes service account tokens to verify identity.</p>"},{"location":"auth-methods/kubernetes/#overview","title":"Overview","text":"<p>Best for: Standard Kubernetes clusters on any cloud provider or on-premises.</p> <p>How it works:</p> <ol> <li>The operator requests a short-lived service account token via the TokenRequest API</li> <li>The token is sent to Vault's Kubernetes auth endpoint</li> <li>Vault validates the token against the Kubernetes API server</li> <li>Vault returns a Vault token with the configured policies</li> </ol> <pre><code>sequenceDiagram\n    participant Op as Operator\n    participant K8s as Kubernetes API\n    participant V as Vault\n\n    Op-&gt;&gt;K8s: 1. TokenRequest\n    K8s--&gt;&gt;Op: 2. SA Token\n    Op-&gt;&gt;V: 3. Login with SA Token\n    V-&gt;&gt;K8s: 4. Validate Token\n    K8s--&gt;&gt;V: 5. Token Valid\n    V--&gt;&gt;Op: 6. Return Vault Token\n    Note over Op: Authenticated</code></pre>"},{"location":"auth-methods/kubernetes/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/kubernetes/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>Kubernetes auth method enabled</li> <li>Network access from Vault to Kubernetes API server</li> </ul>"},{"location":"auth-methods/kubernetes/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Kubernetes v1.25 or later</li> <li>TokenRequest API enabled (enabled by default)</li> <li>ServiceAccount for the operator</li> </ul>"},{"location":"auth-methods/kubernetes/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have <code>kubectl</code> access to your Kubernetes cluster</li> <li>You have <code>vault</code> CLI access or Vault UI access</li> <li>Vault can reach the Kubernetes API server over the network</li> <li>You have permissions to create Vault policies and auth roles</li> </ul>"},{"location":"auth-methods/kubernetes/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/kubernetes/#step-1-enable-kubernetes-auth-in-vault","title":"Step 1: Enable Kubernetes Auth in Vault","text":"<pre><code># Enable the Kubernetes auth method\nvault auth enable kubernetes\n\n# Configure the auth method with the Kubernetes API server\n# If Vault runs in-cluster, it auto-discovers the host\nvault write auth/kubernetes/config \\\n    kubernetes_host=\"https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT\"\n</code></pre> <p>External Vault</p> <p>If Vault runs outside the cluster, you need to provide a CA certificate and explicit host: <pre><code>vault write auth/kubernetes/config \\\n    kubernetes_host=\"https://k8s-api.example.com:6443\" \\\n    kubernetes_ca_cert=@/path/to/ca.crt\n</code></pre></p>"},{"location":"auth-methods/kubernetes/#step-2-create-operator-policy-in-vault","title":"Step 2: Create Operator Policy in Vault","text":"<p>The operator needs permissions to manage policies and auth roles:</p> <pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\n# Manage ACL policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\n\n# List all policies\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# Manage Kubernetes auth roles\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\n\n# List auth roles\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\n\n# Read auth configuration (for health checks)\npath \"auth/kubernetes/config\" {\n  capabilities = [\"read\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/kubernetes/#step-3-create-vault-role-for-the-operator","title":"Step 3: Create Vault Role for the Operator","text":"<pre><code>vault write auth/kubernetes/role/vault-access-operator \\\n    bound_service_account_names=vault-access-operator-controller-manager \\\n    bound_service_account_namespaces=vault-access-operator-system \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre> Parameter Description <code>bound_service_account_names</code> The K8s service account name(s) allowed to authenticate <code>bound_service_account_namespaces</code> The K8s namespace(s) where the SA must exist <code>policies</code> Vault policies to attach to authenticated tokens <code>ttl</code> Token lifetime (1 hour is recommended)"},{"location":"auth-methods/kubernetes/#step-4-create-vaultconnection-resource","title":"Step 4: Create VaultConnection Resource","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n\n  # TLS configuration (if using HTTPS)\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  # Kubernetes authentication\n  auth:\n    kubernetes:\n      role: vault-access-operator\n      # Optional: defaults shown below\n      authPath: kubernetes           # Vault auth mount path\n      tokenDuration: 1h              # SA token lifetime\n      tokenReviewerRotation: true    # Auto-rotate token_reviewer_jwt\n      renewalStrategy: renew         # renew or reauth\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/kubernetes/#step-5-verify-the-connection","title":"Step 5: Verify the Connection","text":"<pre><code># Check VaultConnection status\nkubectl get vaultconnection vault-primary -o yaml\n\n# Expected status\n# status:\n#   phase: Active\n#   healthy: true\n#   vaultVersion: \"1.15.0\"\n</code></pre>"},{"location":"auth-methods/kubernetes/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/kubernetes/#required-fields","title":"Required Fields","text":"Field Description <code>auth.kubernetes.role</code> The Vault role name to authenticate as"},{"location":"auth-methods/kubernetes/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>authPath</code> <code>kubernetes</code> Vault auth mount path <code>tokenDuration</code> <code>1h</code> Requested SA token lifetime <code>kubernetesHost</code> Auto-detected K8s API server URL for Vault config <code>tokenReviewerRotation</code> <code>true</code> Enable automatic token_reviewer_jwt rotation <code>renewalStrategy</code> <code>renew</code> How to refresh Vault tokens: <code>renew</code> or <code>reauth</code>"},{"location":"auth-methods/kubernetes/#token-reviewer-rotation","title":"Token Reviewer Rotation","text":"<p>The <code>tokenReviewerRotation</code> field is critical for security:</p> <ul> <li>When enabled (default): The operator automatically rotates the <code>token_reviewer_jwt</code> used by Vault to validate service account tokens</li> <li>When disabled: You must manually manage token rotation, or authentication will fail when the JWT expires</li> </ul> <p>Do not disable token reviewer rotation</p> <p>Disabling <code>tokenReviewerRotation</code> can cause authentication failures when the token_reviewer_jwt expires. Only disable this if you have an external system managing token rotation.</p>"},{"location":"auth-methods/kubernetes/#renewal-strategy","title":"Renewal Strategy","text":"<p>The <code>renewalStrategy</code> field controls how the operator refreshes Vault tokens:</p> Strategy Behavior Use Case <code>renew</code> (default) Proactively renew tokens via Vault API, fallback to re-auth on failure Most workloads <code>reauth</code> Always re-authenticate with fresh K8s credentials Security-critical workloads"},{"location":"auth-methods/kubernetes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/kubernetes/#connection-stays-in-pending-phase","title":"Connection stays in \"Pending\" phase","text":"<p>Symptoms: <pre><code>status:\n  phase: Pending\n  conditions:\n  - type: Ready\n    status: \"False\"\n    reason: AuthenticationFailed\n</code></pre></p> <p>Possible causes:</p> <ol> <li> <p>Wrong role name: Verify the role exists in Vault    <pre><code>vault read auth/kubernetes/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Service account mismatch: Check SA name and namespace match the Vault role    <pre><code>vault read auth/kubernetes/role/vault-access-operator | grep bound\n</code></pre></p> </li> <li> <p>Network connectivity: Verify Vault can reach the K8s API    <pre><code># From Vault server\ncurl -k https://&lt;k8s-api-server&gt;:6443/healthz\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/kubernetes/#permission-denied-errors","title":"\"permission denied\" errors","text":"<p>Symptoms: <pre><code>Error: permission denied\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check the Vault policy is attached to the role:    <pre><code>vault read auth/kubernetes/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Verify the policy has required permissions:    <pre><code>vault policy read vault-access-operator\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/kubernetes/#token-expiration-errors","title":"Token expiration errors","text":"<p>Symptoms: <pre><code>Error: token is expired\n</code></pre></p> <p>Solutions:</p> <ol> <li>Ensure <code>tokenReviewerRotation</code> is enabled (default)</li> <li>Check operator logs for rotation errors:    <pre><code>kubectl logs -n vault-access-operator-system deploy/vault-access-operator-controller-manager\n</code></pre></li> </ol>"},{"location":"auth-methods/kubernetes/#example-complete-setup","title":"Example: Complete Setup","text":"<p>Here's a complete example for a standard setup:</p> VaultConnectionVault PolicyVault Role <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n  auth:\n    kubernetes:\n      role: vault-access-operator\n  healthCheckInterval: 30s\n</code></pre> <pre><code># vault-access-operator policy\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\npath \"auth/kubernetes/config\" {\n  capabilities = [\"read\"]\n}\n</code></pre> <pre><code>vault write auth/kubernetes/role/vault-access-operator \\\n    bound_service_account_names=vault-access-operator-controller-manager \\\n    bound_service_account_namespaces=vault-access-operator-system \\\n    policies=vault-access-operator \\\n    ttl=1h\n</code></pre>"},{"location":"auth-methods/kubernetes/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Quick start guide</li> <li>API Reference - Complete field reference</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"auth-methods/oidc/","title":"OIDC Authentication","text":"<p>OIDC (OpenID Connect) authentication enables workloads to authenticate to Vault using identity tokens from OIDC providers. This is useful for workload identity federation across EKS, GKE, Azure AKS, and other platforms.</p>"},{"location":"auth-methods/oidc/#overview","title":"Overview","text":"<p>Best for: Workload identity federation with cloud providers (EKS OIDC, GKE, Azure AD).</p> <p>How it works:</p> <ol> <li>The operator requests a service account token with OIDC claims</li> <li>The token is sent to Vault's OIDC auth endpoint</li> <li>Vault validates the token against the configured OIDC provider</li> <li>Vault returns a token with the configured policies</li> </ol> <pre><code>sequenceDiagram\n    participant Op as Operator\n    participant K8s as Kubernetes API\n    participant V as Vault\n    participant OIDC as OIDC Provider&lt;br/&gt;(EKS/GKE/AAD)\n\n    Op-&gt;&gt;K8s: 1. TokenRequest (with audiences)\n    K8s--&gt;&gt;Op: 2. JWT Token\n    Op-&gt;&gt;V: 3. Login with JWT\n    V-&gt;&gt;OIDC: 4. OIDC Discovery\n    OIDC--&gt;&gt;V: 5. Validate JWT\n    V--&gt;&gt;Op: 6. Return Vault Token\n    Note over Op: Authenticated</code></pre>"},{"location":"auth-methods/oidc/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/oidc/#oidc-provider-requirements","title":"OIDC Provider Requirements","text":"EKSGKEAzure AKS <ul> <li>EKS cluster with OIDC provider enabled</li> <li>OIDC issuer URL from cluster configuration</li> </ul> <ul> <li>GKE cluster (OIDC provider automatic)</li> <li>Workload Identity enabled (recommended)</li> </ul> <ul> <li>AKS cluster with OIDC issuer enabled</li> <li>Azure AD Workload Identity configured</li> </ul>"},{"location":"auth-methods/oidc/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server v1.12 or later</li> <li>OIDC or JWT auth method enabled</li> <li>Network access to OIDC discovery endpoint</li> </ul>"},{"location":"auth-methods/oidc/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Kubernetes v1.25 or later</li> <li>ServiceAccount for the operator</li> </ul>"},{"location":"auth-methods/oidc/#assumptions","title":"Assumptions","text":"<p>This guide assumes:</p> <ul> <li>You have access to your cluster's OIDC issuer URL</li> <li>Vault can reach the OIDC discovery endpoint (may require internet access)</li> <li>You have <code>kubectl</code> and <code>vault</code> CLI access</li> </ul>"},{"location":"auth-methods/oidc/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"auth-methods/oidc/#step-1-get-oidc-issuer-url","title":"Step 1: Get OIDC Issuer URL","text":"EKSGKEAzure AKS <pre><code>aws eks describe-cluster \\\n    --name my-cluster \\\n    --query \"cluster.identity.oidc.issuer\" \\\n    --output text\n# Output: https://oidc.eks.us-west-2.amazonaws.com/id/EXAMPLED539D4633E53DE1B716D3041E\n</code></pre> <pre><code>gcloud container clusters describe my-cluster \\\n    --zone us-central1-a \\\n    --format=\"value(selfLink)\"\n# Use: https://container.googleapis.com/v1/projects/PROJECT/locations/ZONE/clusters/CLUSTER\n</code></pre> <pre><code>az aks show \\\n    --resource-group my-rg \\\n    --name my-cluster \\\n    --query \"oidcIssuerProfile.issuerUrl\" \\\n    --output tsv\n# Output: https://eastus.oic.prod-aks.azure.com/TENANT_ID/GUID/\n</code></pre>"},{"location":"auth-methods/oidc/#step-2-enable-oidc-auth-in-vault","title":"Step 2: Enable OIDC Auth in Vault","text":"<pre><code># Enable OIDC auth (or JWT auth for more flexibility)\nvault auth enable oidc\n\n# Configure OIDC discovery\nvault write auth/oidc/config \\\n    oidc_discovery_url=\"$OIDC_ISSUER_URL\" \\\n    default_role=\"vault-access-operator\"\n</code></pre> <p>JWT vs OIDC Auth</p> <p>Vault has two similar auth methods:</p> <ul> <li>OIDC auth: Full OIDC flow with browser redirect (also supports JWT)</li> <li>JWT auth: Pure JWT validation without browser flow</li> </ul> <p>For Kubernetes workloads, either works. JWT auth is simpler for server-to-server auth.</p>"},{"location":"auth-methods/oidc/#step-3-create-vault-policy","title":"Step 3: Create Vault Policy","text":"<pre><code>vault policy write vault-access-operator - &lt;&lt;EOF\n# Manage ACL policies\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# Manage Kubernetes auth roles\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n</code></pre>"},{"location":"auth-methods/oidc/#step-4-create-vault-role","title":"Step 4: Create Vault Role","text":"<pre><code>vault write auth/oidc/role/vault-access-operator \\\n    role_type=\"jwt\" \\\n    bound_audiences=\"vault\" \\\n    user_claim=\"sub\" \\\n    policies=\"vault-access-operator\" \\\n    ttl=\"1h\"\n</code></pre> Parameter Description <code>role_type</code> Use <code>jwt</code> for service account tokens <code>bound_audiences</code> Audience claim(s) required in the JWT <code>user_claim</code> JWT claim to use as identity (usually <code>sub</code>) <code>policies</code> Vault policies to attach <code>ttl</code> Token lifetime"},{"location":"auth-methods/oidc/#step-5-create-vaultconnection-resource","title":"Step 5: Create VaultConnection Resource","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-oidc\nspec:\n  address: https://vault.example.com:8200\n\n  tls:\n    caCert:\n      secretRef:\n        name: vault-ca-cert\n        namespace: vault-access-operator-system\n        key: ca.crt\n\n  auth:\n    oidc:\n      role: vault-access-operator\n      authPath: oidc\n      providerURL: https://oidc.eks.us-west-2.amazonaws.com/id/CLUSTER_ID\n      audiences:\n        - vault\n      useServiceAccountToken: true\n      tokenDuration: 1h\n</code></pre> <p>Apply the configuration:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/oidc/#step-6-verify-the-connection","title":"Step 6: Verify the Connection","text":"<pre><code>kubectl get vaultconnection vault-oidc -o yaml\n\n# Expected status\n# status:\n#   phase: Active\n#   healthy: true\n</code></pre>"},{"location":"auth-methods/oidc/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/oidc/#required-fields","title":"Required Fields","text":"Field Description <code>auth.oidc.role</code> The Vault role name to authenticate as"},{"location":"auth-methods/oidc/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>authPath</code> <code>oidc</code> Vault auth mount path <code>providerURL</code> None OIDC provider URL for documentation <code>audiences</code> <code>[\"vault\"]</code> Audience claim(s) in the JWT <code>tokenDuration</code> <code>1h</code> SA token lifetime <code>useServiceAccountToken</code> <code>true</code> Use K8s SA token for auth <code>jwtSecretRef</code> None Use external JWT instead of SA token <code>userClaim</code> <code>sub</code> JWT claim for entity alias <code>groupsClaim</code> None JWT claim for group membership <code>scopes</code> None OIDC scopes (for browser flow)"},{"location":"auth-methods/oidc/#platform-specific-examples","title":"Platform-Specific Examples","text":"EKSGKEAzure AKS <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-eks-oidc\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    oidc:\n      role: vault-access-operator\n      providerURL: https://oidc.eks.us-west-2.amazonaws.com/id/CLUSTER_ID\n      audiences:\n        - sts.amazonaws.com    # EKS default audience\n      useServiceAccountToken: true\n</code></pre> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-gke-oidc\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    oidc:\n      role: vault-access-operator\n      providerURL: https://container.googleapis.com/v1/projects/PROJECT/locations/ZONE/clusters/CLUSTER\n      audiences:\n        - vault\n      useServiceAccountToken: true\n</code></pre> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-aks-oidc\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    oidc:\n      role: vault-access-operator\n      providerURL: https://eastus.oic.prod-aks.azure.com/TENANT_ID/GUID/\n      audiences:\n        - api://AzureADTokenExchange\n      useServiceAccountToken: true\n</code></pre>"},{"location":"auth-methods/oidc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/oidc/#oidc-discovery-failed-error","title":"\"OIDC discovery failed\" error","text":"<p>Symptoms: <pre><code>Error: error fetching OIDC discovery document\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Verify Vault can reach the OIDC discovery endpoint:    <pre><code># From Vault server\ncurl -s \"$OIDC_ISSUER_URL/.well-known/openid-configuration\"\n</code></pre></p> </li> <li> <p>For private clusters, ensure network connectivity or use JWT auth with manual JWKS</p> </li> </ol>"},{"location":"auth-methods/oidc/#audience-claim-mismatch-error","title":"\"audience claim mismatch\" error","text":"<p>Symptoms: <pre><code>Error: audience claim does not match\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check the audience in your VaultConnection matches the Vault role:    <pre><code>vault read auth/oidc/role/vault-access-operator\n</code></pre></p> </li> <li> <p>Verify the SA token has the expected audience:    <pre><code># Get a token and decode it\nkubectl create token vault-access-operator-controller-manager \\\n    -n vault-access-operator-system \\\n    --audience=vault | jwt decode -\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/oidc/#invalid-issuer-error","title":"\"invalid issuer\" error","text":"<p>Symptoms: <pre><code>Error: issuer claim does not match\n</code></pre></p> <p>Solutions:</p> <ol> <li>Verify the OIDC issuer URL is exactly correct (no trailing slash)</li> <li>Check the Vault OIDC config matches:    <pre><code>vault read auth/oidc/config\n</code></pre></li> </ol>"},{"location":"auth-methods/oidc/#see-also","title":"See Also","text":"<ul> <li>JWT Authentication - Alternative for generic JWT</li> <li>Kubernetes Authentication - Simpler for standard setups</li> <li>AWS IAM Authentication - Better for EKS with IRSA</li> <li>GCP IAM Authentication - Better for GKE with Workload Identity</li> </ul>"},{"location":"auth-methods/token/","title":"Token Authentication","text":"<p>Token authentication uses a static Vault token stored in a Kubernetes secret. This is the simplest authentication method but offers the least security.</p> <p>Development Only</p> <p>Token authentication should never be used in production. It uses long-lived, static credentials that:</p> <ul> <li>Don't automatically rotate</li> <li>Can be easily leaked</li> <li>Provide no audit trail of who used them</li> <li>Cannot be scoped to specific workloads</li> </ul>"},{"location":"auth-methods/token/#overview","title":"Overview","text":"<p>Best for: Local development, quick testing, demos.</p> <p>How it works:</p> <ol> <li>A Vault token is stored in a Kubernetes secret</li> <li>The operator reads the token from the secret</li> <li>The token is used directly for Vault API calls</li> </ol> <pre><code>sequenceDiagram\n    participant S as K8s Secret&lt;br/&gt;(Vault Token)\n    participant Op as Operator\n    participant V as Vault\n\n    Op-&gt;&gt;S: 1. Read token\n    S--&gt;&gt;Op: Vault Token\n    Op-&gt;&gt;V: 2. Use token\n    V--&gt;&gt;Op: 3. Authenticated</code></pre>"},{"location":"auth-methods/token/#prerequisites","title":"Prerequisites","text":""},{"location":"auth-methods/token/#vault-requirements","title":"Vault Requirements","text":"<ul> <li>Vault server running and accessible</li> <li>A Vault token with appropriate permissions</li> </ul>"},{"location":"auth-methods/token/#kubernetes-requirements","title":"Kubernetes Requirements","text":"<ul> <li>Secret containing the Vault token</li> </ul>"},{"location":"auth-methods/token/#quick-setup","title":"Quick Setup","text":""},{"location":"auth-methods/token/#step-1-create-vault-token","title":"Step 1: Create Vault Token","text":"<p>For development, you can use the root token or create a limited token:</p> <pre><code># Option A: Use root token (dev only!)\n# The root token is printed when starting Vault in dev mode\n\n# Option B: Create a limited token\nvault policy write vault-access-operator - &lt;&lt;EOF\npath \"sys/policies/acl/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"]\n}\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\nEOF\n\nvault token create -policy=vault-access-operator -ttl=24h\n</code></pre>"},{"location":"auth-methods/token/#step-2-create-kubernetes-secret","title":"Step 2: Create Kubernetes Secret","text":"<pre><code>kubectl create secret generic vault-token \\\n    -n vault-access-operator-system \\\n    --from-literal=token=hvs.your-token-here\n</code></pre>"},{"location":"auth-methods/token/#step-3-create-vaultconnection","title":"Step 3: Create VaultConnection","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-dev\nspec:\n  address: http://vault.default.svc:8200  # or http://localhost:8200\n\n  auth:\n    token:\n      secretRef:\n        name: vault-token\n        namespace: vault-access-operator-system\n        key: token\n</code></pre> <p>Apply:</p> <pre><code>kubectl apply -f vaultconnection.yaml\n</code></pre>"},{"location":"auth-methods/token/#step-4-verify","title":"Step 4: Verify","text":"<pre><code>kubectl get vaultconnection vault-dev\n</code></pre>"},{"location":"auth-methods/token/#configuration-reference","title":"Configuration Reference","text":""},{"location":"auth-methods/token/#required-fields","title":"Required Fields","text":"Field Description <code>auth.token.secretRef.name</code> Name of the secret containing the token <code>auth.token.secretRef.key</code> Key within the secret"},{"location":"auth-methods/token/#optional-fields","title":"Optional Fields","text":"Field Default Description <code>secretRef.namespace</code> VaultConnection namespace Namespace of the secret"},{"location":"auth-methods/token/#local-development-setup","title":"Local Development Setup","text":"<p>For local development with Vault in dev mode:</p> <pre><code># Start Vault in dev mode\nvault server -dev -dev-root-token-id=root\n\n# In another terminal, export the address\nexport VAULT_ADDR=http://127.0.0.1:8200\nexport VAULT_TOKEN=root\n\n# Create the secret\nkubectl create secret generic vault-token \\\n    -n vault-access-operator-system \\\n    --from-literal=token=root\n</code></pre> <p>VaultConnection for local development:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-local\nspec:\n  address: http://host.docker.internal:8200  # For Docker Desktop\n  # address: http://172.17.0.1:8200          # For Linux\n  auth:\n    token:\n      secretRef:\n        name: vault-token\n        namespace: vault-access-operator-system\n        key: token\n</code></pre>"},{"location":"auth-methods/token/#security-warnings","title":"Security Warnings","text":""},{"location":"auth-methods/token/#why-token-auth-is-dangerous-in-production","title":"Why Token Auth is Dangerous in Production","text":"Issue Impact No rotation Compromised tokens remain valid until manually revoked No identity Vault can't distinguish between uses of the same token Audit gaps Logs show token ID but not the actual user/workload Credential sprawl Tokens may be copied to multiple locations No scope limits Token has same permissions everywhere it's used"},{"location":"auth-methods/token/#alternatives-for-production","title":"Alternatives for Production","text":"Method Use Case Kubernetes Auth Standard K8s clusters AWS IAM EKS with IRSA GCP IAM GKE with Workload Identity AppRole CI/CD pipelines"},{"location":"auth-methods/token/#troubleshooting","title":"Troubleshooting","text":""},{"location":"auth-methods/token/#token-is-expired-error","title":"\"token is expired\" error","text":"<p>Symptoms: <pre><code>Error: permission denied\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check token TTL:    <pre><code>vault token lookup &lt;token&gt;\n</code></pre></p> </li> <li> <p>Create a new token:    <pre><code>vault token create -policy=vault-access-operator\n</code></pre></p> </li> <li> <p>Update the secret:    <pre><code>kubectl create secret generic vault-token \\\n    -n vault-access-operator-system \\\n    --from-literal=token=&lt;new-token&gt; \\\n    --dry-run=client -o yaml | kubectl apply -f -\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/token/#connection-refused-local-development","title":"Connection refused (local development)","text":"<p>Symptoms: <pre><code>Error: dial tcp 127.0.0.1:8200: connect: connection refused\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>For Docker Desktop, use <code>host.docker.internal</code>:    <pre><code>address: http://host.docker.internal:8200\n</code></pre></p> </li> <li> <p>For Linux, use the Docker bridge IP:    <pre><code>address: http://172.17.0.1:8200\n</code></pre></p> </li> <li> <p>Or run Vault with network binding:    <pre><code>vault server -dev -dev-listen-address=0.0.0.0:8200\n</code></pre></p> </li> </ol>"},{"location":"auth-methods/token/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Authentication - Recommended for production</li> <li>Bootstrap Authentication - For initial setup</li> <li>Getting Started - Complete setup guide</li> </ul>"},{"location":"concepts/","title":"Concepts Overview","text":"<p>This section explains the core concepts and design principles behind the Vault Access Operator.</p>"},{"location":"concepts/#what-is-vault-access-operator","title":"What is Vault Access Operator?","text":"<p>Vault Access Operator is a Kubernetes operator that manages HashiCorp Vault resources using native Kubernetes workflows. It follows the declarative approach of Kubernetes: you define the desired state, and the operator ensures Vault matches that state.</p>"},{"location":"concepts/#core-design-principles","title":"Core Design Principles","text":""},{"location":"concepts/#1-declarative-configuration","title":"1. Declarative Configuration","text":"<p>Instead of running imperative <code>vault</code> CLI commands, you define Vault resources as Kubernetes Custom Resources (CRs):</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: my-app-read\n  namespace: production\nspec:\n  vaultConnectionRef:\n    name: vault-primary\n  rules:\n    - path: \"secret/data/production/*\"\n      capabilities: [\"read\", \"list\"]\n</code></pre> <p>The operator continuously reconciles this desired state with Vault.</p>"},{"location":"concepts/#2-kubernetes-native-experience","title":"2. Kubernetes-Native Experience","text":"<ul> <li>Familiar tooling: Use <code>kubectl</code>, Helm, Kustomize, ArgoCD</li> <li>RBAC integration: Kubernetes RBAC controls who can create Vault resources</li> <li>Namespace isolation: VaultPolicy and VaultRole are namespaced; VaultClusterPolicy and VaultClusterRole are cluster-scoped</li> <li>GitOps compatible: Store Vault configuration in Git</li> </ul>"},{"location":"concepts/#3-feature-driven-architecture","title":"3. Feature-Driven Architecture","text":"<p>The operator is organized as independent features that can be enabled/disabled:</p> Feature Resources Purpose Connection VaultConnection Authenticate and connect to Vault Policy VaultPolicy, VaultClusterPolicy Manage Vault ACL policies Role VaultRole, VaultClusterRole Manage Kubernetes auth roles Discovery (built into VaultConnection) Find unmanaged Vault resources"},{"location":"concepts/#custom-resource-definitions","title":"Custom Resource Definitions","text":""},{"location":"concepts/#resource-hierarchy","title":"Resource Hierarchy","text":"<pre><code>graph TD\n    VC[\"VaultConnection&lt;br/&gt;(cluster-scoped)\"]\n    VCP[\"VaultClusterPolicy&lt;br/&gt;(cluster-scoped)\"]\n    VP[\"VaultPolicy&lt;br/&gt;(namespaced)\"]\n    VCR[\"VaultClusterRole&lt;br/&gt;(cluster-scoped)\"]\n    VR[\"VaultRole&lt;br/&gt;(namespaced)\"]\n\n    VC --&gt;|authenticates| Vault[\"HashiCorp Vault\"]\n    VCP --&gt;|manages| Policies[\"Vault ACL Policies\"]\n    VP --&gt;|manages| Policies\n    VCR --&gt;|binds SAs to| Policies\n    VR --&gt;|binds SAs to| Policies\n    VCR -.-&gt;|references| VCP\n    VCR -.-&gt;|references| VP\n    VR -.-&gt;|references| VP</code></pre>"},{"location":"concepts/#naming-convention","title":"Naming Convention","text":"<p>Resources in Vault are named with a prefix derived from their Kubernetes context:</p> K8s Resource Vault Name Pattern VaultPolicy <code>foo</code> in namespace <code>bar</code> <code>bar-foo</code> VaultClusterPolicy <code>foo</code> <code>foo</code> VaultRole <code>foo</code> in namespace <code>bar</code> <code>bar-foo</code> VaultClusterRole <code>foo</code> <code>foo</code>"},{"location":"concepts/#key-concepts","title":"Key Concepts","text":""},{"location":"concepts/#architecture","title":"Architecture","text":"<p>Learn about the operator's internal structure, controller patterns, and reconciliation flow.</p>"},{"location":"concepts/#drift-detection","title":"Drift Detection","text":"<p>Understand how the operator detects and optionally corrects configuration drift between Kubernetes and Vault.</p>"},{"location":"concepts/#discovery","title":"Discovery","text":"<p>Discover how to find existing Vault resources that aren't yet managed by Kubernetes CRs.</p>"},{"location":"concepts/#resource-lifecycle","title":"Resource Lifecycle","text":""},{"location":"concepts/#creation-flow","title":"Creation Flow","text":"<pre><code>flowchart TD\n    A[\"1. User creates CR (kubectl apply)\"] --&gt; B[\"2. Operator detects new resource\"]\n    B --&gt; C[\"3. Validates configuration\"]\n    C --&gt; D[\"4. Creates resource in Vault\"]\n    D --&gt; E[\"5. Updates CR status (phase: Active)\"]</code></pre>"},{"location":"concepts/#update-flow","title":"Update Flow","text":"<pre><code>flowchart TD\n    A[\"1. User updates CR\"] --&gt; B[\"2. Operator detects change (generation changed)\"]\n    B --&gt; C[\"3. Compares desired vs actual state\"]\n    C --&gt; D[\"4. Updates Vault resource\"]\n    D --&gt; E[\"5. Updates CR status\"]</code></pre>"},{"location":"concepts/#deletion-flow","title":"Deletion Flow","text":"<pre><code>flowchart TD\n    A[\"1. User deletes CR (kubectl delete)\"] --&gt; B[\"2. Operator detects deletion (has finalizer)\"]\n    B --&gt; C{\"3. deletionPolicy?\"}\n    C -- Delete --&gt; D[\"4a. Removes from Vault\"]\n    C -- Retain --&gt; E[\"4b. Leaves in Vault\"]\n    D --&gt; F[\"5. Removes finalizer, CR deleted\"]\n    E --&gt; F</code></pre>"},{"location":"concepts/#status-fields","title":"Status Fields","text":"<p>All managed resources share common status patterns:</p> Field Description <code>phase</code> Current state: Pending, Syncing, Active, Error, Conflict <code>conditions</code> Detailed conditions (Ready, Synced, etc.) <code>lastSyncedAt</code> When the resource was last synced to Vault <code>driftDetected</code> Whether configuration drift exists <code>lastReconcileID</code> Correlation ID for log filtering"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - Deep dive into operator internals</li> <li>Drift Detection - Understand drift modes</li> <li>Discovery - Find unmanaged Vault resources</li> <li>Authentication Methods - Choose your auth method</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This document explains the internal architecture of the Vault Access Operator.</p>"},{"location":"concepts/architecture/#high-level-overview","title":"High-Level Overview","text":"<pre><code>graph TD\n    subgraph K8s[\"Kubernetes Cluster\"]\n        subgraph Operator[\"Vault Access Operator\"]\n            CF[\"Connection Feature\"]\n            PF[\"Policy Feature\"]\n            RF[\"Role Feature\"]\n            DF[\"Discovery Feature\"]\n            VC[\"Vault Client&lt;br/&gt;(pkg/vault)\"]\n        end\n    end\n    V[\"HashiCorp Vault\"]\n\n    CF --&gt; VC\n    PF --&gt; VC\n    RF --&gt; VC\n    DF --&gt; VC\n    VC --&gt; V</code></pre>"},{"location":"concepts/architecture/#feature-driven-design","title":"Feature-Driven Design","text":"<p>The operator follows a feature-driven architecture where each domain (connection, policy, role, discovery) is self-contained:</p> <pre><code>features/\n\u251c\u2500\u2500 connection/\n\u2502   \u251c\u2500\u2500 feature.go        # Feature registration\n\u2502   \u2514\u2500\u2500 controller/       # Reconciler, handler\n\u251c\u2500\u2500 policy/\n\u2502   \u251c\u2500\u2500 feature.go\n\u2502   \u251c\u2500\u2500 controller/       # Policy + ClusterPolicy reconcilers\n\u2502   \u2514\u2500\u2500 domain/           # Business logic adapters\n\u251c\u2500\u2500 role/\n\u2502   \u251c\u2500\u2500 feature.go\n\u2502   \u251c\u2500\u2500 controller/\n\u2502   \u2514\u2500\u2500 domain/\n\u2514\u2500\u2500 discovery/\n    \u251c\u2500\u2500 feature.go\n    \u2514\u2500\u2500 controller/       # Scanner implementation\n</code></pre>"},{"location":"concepts/architecture/#benefits","title":"Benefits","text":"<ol> <li>Isolation: Each feature can be developed and tested independently</li> <li>Pluggability: Features can be enabled/disabled at startup</li> <li>Maintainability: Clear ownership and separation of concerns</li> <li>Testability: Domain logic separated from K8s/Vault infrastructure</li> </ol>"},{"location":"concepts/architecture/#controller-pattern","title":"Controller Pattern","text":"<p>Each resource type has a dedicated controller following the standard Kubernetes controller pattern:</p> <pre><code>flowchart LR\n    A[\"Watch Events\"] --&gt; B[\"Enqueue&lt;br/&gt;(workqueue)\"]\n    B --&gt; C[\"Reconcile&lt;br/&gt;(business logic)\"]\n    C --&gt; D[\"Requeue&lt;br/&gt;(delay)\"]\n    D -.-&gt; A</code></pre>"},{"location":"concepts/architecture/#basereconciler","title":"BaseReconciler","text":"<p>All controllers use a shared <code>BaseReconciler</code> that provides:</p> <ul> <li>Finalizer management</li> <li>Status updates</li> <li>Error handling</li> <li>Requeue logic</li> <li>ReconcileID tracking</li> </ul> <pre><code>// BaseReconciler provides common reconciliation patterns\ntype BaseReconciler[T client.Object] struct {\n    client   client.Client\n    scheme   *runtime.Scheme\n    log      logr.Logger\n    finalizer string\n    recorder record.EventRecorder\n}\n\n// Reconcile handles the common reconciliation flow\nfunc (r *BaseReconciler[T]) Reconcile(\n    ctx context.Context,\n    req ctrl.Request,\n    handler FeatureHandler[T],\n    newObj func() T,\n) (ctrl.Result, error)\n</code></pre>"},{"location":"concepts/architecture/#featurehandler-interface","title":"FeatureHandler Interface","text":"<p>Each feature implements the <code>FeatureHandler</code> interface:</p> <pre><code>type FeatureHandler[T client.Object] interface {\n    // Sync creates or updates the resource in Vault\n    Sync(ctx context.Context, obj T) error\n\n    // Cleanup removes the resource from Vault\n    Cleanup(ctx context.Context, obj T) error\n}\n</code></pre>"},{"location":"concepts/architecture/#reconciliation-flow","title":"Reconciliation Flow","text":""},{"location":"concepts/architecture/#sync-flow-createupdate","title":"Sync Flow (Create/Update)","text":"<pre><code>flowchart TD\n    A[\"1. Reconcile triggered\"] --&gt; B[\"2. Get resource from API server\"]\n    B --&gt; C{\"3. Being deleted?\"}\n    C -- Yes --&gt; cleanup[\"Cleanup Flow\"]\n    C -- No --&gt; D[\"4. Ensure finalizer exists\"]\n    D --&gt; E[\"5. Get VaultConnection\"]\n    E --&gt; F[\"6. Get Vault client\"]\n    F --&gt; G{\"7. Exists in Vault?\"}\n    G -- No --&gt; H[\"Create in Vault\"]\n    G -- Yes --&gt; I[\"Check drift \u2192 Update if needed\"]\n    H --&gt; J[\"8. Update status\"]\n    I --&gt; J\n    J --&gt; K[\"9. Requeue after interval\"]</code></pre>"},{"location":"concepts/architecture/#cleanup-flow-delete","title":"Cleanup Flow (Delete)","text":"<pre><code>flowchart TD\n    A[\"1. Resource has deletion timestamp\"] --&gt; B{\"2. deletionPolicy?\"}\n    B -- Retain --&gt; skip[\"Skip Vault deletion\"]\n    B -- Delete --&gt; C[\"3. Get Vault client\"]\n    skip --&gt; E[\"5. Remove finalizer\"]\n    C --&gt; D[\"4. Delete from Vault\"]\n    D --&gt; E\n    E --&gt; F[\"6. Resource deleted\"]</code></pre>"},{"location":"concepts/architecture/#domain-adapters","title":"Domain Adapters","text":"<p>Domain adapters abstract the differences between namespaced and cluster-scoped resources:</p> <pre><code>// PolicyAdapter provides a unified interface for VaultPolicy and VaultClusterPolicy\ntype PolicyAdapter interface {\n    GetName() string\n    GetNamespace() string\n    GetVaultPolicyName() string\n    GetConnectionRef() vaultv1alpha1.ConnectionReference\n    GetRules() []vaultv1alpha1.PolicyRule\n    GetDriftMode() vaultv1alpha1.DriftMode\n    // ... status setters\n}\n</code></pre> <p>This allows the same business logic to handle both: - <code>VaultPolicy</code> (namespaced) \u2192 policy name: <code>namespace-name</code> - <code>VaultClusterPolicy</code> (cluster-scoped) \u2192 policy name: <code>name</code></p>"},{"location":"concepts/architecture/#vault-client-layer","title":"Vault Client Layer","text":"<p>The <code>pkg/vault</code> package provides a client abstraction:</p> <pre><code>type Client struct {\n    client     *api.Client\n    authConfig AuthConfig\n    log        logr.Logger\n}\n\n// Policy operations\nfunc (c *Client) ReadPolicy(ctx context.Context, name string) (string, error)\nfunc (c *Client) WritePolicy(ctx context.Context, name, rules string) error\nfunc (c *Client) DeletePolicy(ctx context.Context, name string) error\n\n// Role operations\nfunc (c *Client) ReadKubernetesAuthRole(ctx context.Context, authPath, roleName string) (*RoleConfig, error)\nfunc (c *Client) WriteKubernetesAuthRole(ctx context.Context, authPath, roleName string, config *RoleConfig) error\nfunc (c *Client) DeleteKubernetesAuthRole(ctx context.Context, authPath, roleName string) error\n\n// Authentication\nfunc (c *Client) Authenticate(ctx context.Context) error\nfunc (c *Client) RenewToken(ctx context.Context) error\n</code></pre>"},{"location":"concepts/architecture/#authentication-flow","title":"Authentication Flow","text":"<pre><code>sequenceDiagram\n    participant VC as VaultConnection\n    participant K8s as Kubernetes API\n    participant V as Vault Server\n\n    VC-&gt;&gt;K8s: TokenRequest (ServiceAccount)\n    K8s--&gt;&gt;VC: SA JWT Token\n    VC-&gt;&gt;V: Login with SA JWT\n    V-&gt;&gt;K8s: Validate Token\n    K8s--&gt;&gt;V: Token Valid\n    V--&gt;&gt;VC: Vault Token\n    Note over VC: Token Cached + Renewal</code></pre>"},{"location":"concepts/architecture/#renewal-strategy","title":"Renewal Strategy","text":"<p>The operator supports two token renewal strategies:</p> Strategy Behavior <code>renew</code> (default) Renew existing token before expiration <code>reauth</code> Re-authenticate with fresh credentials"},{"location":"concepts/architecture/#status-management","title":"Status Management","text":""},{"location":"concepts/architecture/#phase-transitions","title":"Phase Transitions","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Pending\n    Pending --&gt; Syncing\n    Syncing --&gt; Active\n    Syncing --&gt; Error\n    Active --&gt; Error\n    Pending --&gt; Conflict\n    Error --&gt; Conflict\n    Active --&gt; Deleting\n    Deleting --&gt; [*]</code></pre>"},{"location":"concepts/architecture/#conditions","title":"Conditions","text":"<p>Resources track detailed conditions:</p> Condition Description <code>Ready</code> Resource is ready for use <code>Synced</code> Resource is synced to Vault <code>ConnectionReady</code> VaultConnection is available <code>PoliciesResolved</code> Referenced policies exist"},{"location":"concepts/architecture/#metrics-and-observability","title":"Metrics and Observability","text":""},{"location":"concepts/architecture/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>vault_access_operator_reconcile_total{resource, status}\nvault_access_operator_reconcile_duration_seconds{resource}\nvault_access_operator_vault_operations_total{operation, status}\nvault_access_operator_drift_detected{resource}\nvault_access_operator_discovery_scans_total{connection, status}\nvault_access_operator_discovered_resources{connection, type}\n</code></pre>"},{"location":"concepts/architecture/#structured-logging","title":"Structured Logging","text":"<p>All log entries include:</p> <pre><code>{\n  \"level\": \"info\",\n  \"ts\": \"2026-01-15T10:30:00Z\",\n  \"logger\": \"vaultpolicy\",\n  \"msg\": \"reconciling resource\",\n  \"reconcileID\": \"abc123\",\n  \"namespace\": \"production\",\n  \"name\": \"my-policy\"\n}\n</code></pre> <p>Filter logs by reconcileID: <pre><code>kubectl logs deploy/vault-access-operator-controller-manager | \\\n  jq 'select(.reconcileID == \"abc123\")'\n</code></pre></p>"},{"location":"concepts/architecture/#error-handling","title":"Error Handling","text":""},{"location":"concepts/architecture/#retry-with-backoff","title":"Retry with Backoff","text":"<p>Failed operations are automatically retried with exponential backoff:</p> <pre><code>Attempt 1: immediate\nAttempt 2: 30s delay\nAttempt 3: 1m delay\nAttempt 4: 2m delay\n...\nMax delay: 5m\n</code></pre>"},{"location":"concepts/architecture/#error-categories","title":"Error Categories","text":"Category Behavior Transient (network, timeout) Requeue with backoff Conflict Set status, wait for resolution Validation Set error status, no requeue Permanent (auth failed) Set error status, alert"},{"location":"concepts/architecture/#see-also","title":"See Also","text":"<ul> <li>Drift Detection - How drift is detected and corrected</li> <li>Discovery - Finding unmanaged resources</li> <li>API Reference - Complete CRD reference</li> </ul>"},{"location":"concepts/discovery/","title":"Resource Discovery","text":"<p>Resource discovery scans Vault to find policies and roles that aren't yet managed by Kubernetes Custom Resources. This helps you migrate existing Vault configurations to declarative management.</p>"},{"location":"concepts/discovery/#what-is-discovery","title":"What is Discovery?","text":"<p>When adopting Vault Access Operator in an existing environment, you likely have:</p> <ul> <li>Policies created manually via <code>vault policy write</code></li> <li>Kubernetes auth roles configured directly</li> <li>Resources created by other tools or scripts</li> </ul> <p>Discovery finds these unmanaged resources so you can:</p> <ol> <li>Audit what exists in Vault</li> <li>Adopt resources into Kubernetes management</li> <li>Detect configuration drift</li> </ol>"},{"location":"concepts/discovery/#how-it-works","title":"How It Works","text":"<pre><code>flowchart LR\n    A[\"VaultConnection&lt;br/&gt;(discovery.enabled=true)\"] --&gt; B[\"List Vault Resources&lt;br/&gt;(policies, roles)\"]\n    B --&gt; C[\"Filter by Pattern&lt;br/&gt;&amp; Exclude System Policies\"]\n    C --&gt; D[\"Unmanaged Resources&lt;br/&gt;(no matching CR)\"]\n    D --&gt; E[\"Compare with&lt;br/&gt;K8s Resources\"]\n    E --&gt; F[\"Update Status&lt;br/&gt;(discovered resources)\"]</code></pre>"},{"location":"concepts/discovery/#enabling-discovery","title":"Enabling Discovery","text":"<p>Enable discovery on your VaultConnection:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n\n  auth:\n    kubernetes:\n      role: vault-access-operator\n\n  discovery:\n    enabled: true\n    interval: 1h               # How often to scan\n    policyPatterns:            # Only discover matching policies\n      - \"app-*\"\n      - \"team-*\"\n    rolePatterns:              # Only discover matching roles\n      - \"*-service\"\n    excludeSystemPolicies: true  # Skip root, default, etc.\n</code></pre>"},{"location":"concepts/discovery/#configuration-reference","title":"Configuration Reference","text":""},{"location":"concepts/discovery/#discovery-fields","title":"Discovery Fields","text":"Field Default Description <code>enabled</code> <code>false</code> Enable resource discovery <code>interval</code> <code>1h</code> How often to scan Vault <code>policyPatterns</code> <code>[]</code> (all) Glob patterns for policy names <code>rolePatterns</code> <code>[]</code> (all) Glob patterns for role names <code>excludeSystemPolicies</code> <code>true</code> Skip built-in Vault policies"},{"location":"concepts/discovery/#system-policies","title":"System Policies","text":"<p>By default, these built-in policies are excluded:</p> <ul> <li><code>root</code> - Superuser policy</li> <li><code>default</code> - Default policy for all tokens</li> <li><code>response-wrapping</code> - Used for wrapped responses</li> </ul>"},{"location":"concepts/discovery/#viewing-discovered-resources","title":"Viewing Discovered Resources","text":""},{"location":"concepts/discovery/#via-kubectl","title":"Via kubectl","text":"<pre><code>kubectl get vaultconnection vault-primary -o yaml\n</code></pre> <pre><code>status:\n  phase: Active\n  discoveryStatus:\n    lastScanAt: \"2026-01-15T10:00:00Z\"\n    unmanagedPolicies: 3\n    unmanagedRoles: 2\n    discoveredResources:\n      - type: policy\n        name: app-database-read\n        discoveredAt: \"2026-01-15T10:00:00Z\"\n        suggestedCRName: app-database-read\n        adoptionStatus: discovered\n      - type: policy\n        name: team-platform-admin\n        discoveredAt: \"2026-01-15T10:00:00Z\"\n        suggestedCRName: team-platform-admin\n        adoptionStatus: discovered\n      - type: role\n        name: api-service\n        discoveredAt: \"2026-01-15T10:00:00Z\"\n        suggestedCRName: api-service\n        adoptionStatus: discovered\n</code></pre>"},{"location":"concepts/discovery/#via-prometheus-metrics","title":"Via Prometheus Metrics","text":"<pre><code>vault_access_operator_discovered_resources{connection=\"vault-primary\", type=\"policy\"} 3\nvault_access_operator_discovered_resources{connection=\"vault-primary\", type=\"role\"} 2\nvault_access_operator_discovery_scans_total{connection=\"vault-primary\", status=\"success\"} 10\n</code></pre>"},{"location":"concepts/discovery/#adopting-discovered-resources","title":"Adopting Discovered Resources","text":"<p>Once you've identified unmanaged resources, you can adopt them into Kubernetes management.</p>"},{"location":"concepts/discovery/#step-1-review-the-resource","title":"Step 1: Review the Resource","text":"<pre><code># Check what the policy contains\nvault policy read app-database-read\n\n# Check what the role contains\nvault read auth/kubernetes/role/api-service\n</code></pre>"},{"location":"concepts/discovery/#step-2-create-a-kubernetes-cr","title":"Step 2: Create a Kubernetes CR","text":"<pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: app-database-read\n  namespace: production\n  annotations:\n    vault.platform.io/adopt: \"true\"  # Adopt existing resource\nspec:\n  vaultConnectionRef:\n    name: vault-primary\n  rules:\n    - path: \"database/creds/readonly\"\n      capabilities: [\"read\"]\n</code></pre>"},{"location":"concepts/discovery/#step-3-apply-and-verify","title":"Step 3: Apply and Verify","text":"<pre><code>kubectl apply -f policy.yaml\n\n# Check adoption status\nkubectl get vaultpolicy app-database-read -o yaml\n</code></pre> <pre><code>status:\n  phase: Active\n  managed: true\n  message: \"Adopted existing Vault resource\"\n</code></pre>"},{"location":"concepts/discovery/#adoption-modes","title":"Adoption Modes","text":""},{"location":"concepts/discovery/#adopt-existing-vaultplatformioadopt-true","title":"Adopt Existing (<code>vault.platform.io/adopt: \"true\"</code>)","text":"<ul> <li>Takes ownership of existing Vault resource</li> <li>Does NOT modify the resource (initially)</li> <li>Future updates to the CR will sync to Vault</li> </ul>"},{"location":"concepts/discovery/#fail-on-conflict-default","title":"Fail on Conflict (default)","text":"<p>Without the adopt annotation: - If resource exists in Vault, CR enters <code>Conflict</code> phase - Resource is NOT overwritten - Requires explicit adoption or deletion</p>"},{"location":"concepts/discovery/#pattern-matching","title":"Pattern Matching","text":"<p>Discovery uses glob patterns (shell-style wildcards):</p> Pattern Matches Doesn't Match <code>app-*</code> <code>app-frontend</code>, <code>app-backend</code> <code>my-app</code>, <code>frontend</code> <code>*-prod</code> <code>api-prod</code>, <code>web-prod</code> <code>prod-api</code>, <code>production</code> <code>team-*-*</code> <code>team-platform-admin</code> <code>team-platform</code>"},{"location":"concepts/discovery/#multiple-patterns","title":"Multiple Patterns","text":"<p>Multiple patterns are OR'd together:</p> <pre><code>discovery:\n  policyPatterns:\n    - \"app-*\"      # OR\n    - \"service-*\"  # OR\n    - \"team-*\"\n</code></pre>"},{"location":"concepts/discovery/#best-practices","title":"Best Practices","text":""},{"location":"concepts/discovery/#1-start-with-detection-only","title":"1. Start with Detection Only","text":"<p>Don't adopt everything immediately:</p> <pre><code>discovery:\n  enabled: true\n  interval: 24h  # Daily scan\n</code></pre> <p>Review discovered resources, understand their purpose, then adopt selectively.</p>"},{"location":"concepts/discovery/#2-use-specific-patterns","title":"2. Use Specific Patterns","text":"<p>Avoid discovering resources you don't want to manage:</p> <pre><code>discovery:\n  policyPatterns:\n    - \"myteam-*\"  # Only our team's resources\n  excludeSystemPolicies: true\n</code></pre>"},{"location":"concepts/discovery/#3-document-before-adopting","title":"3. Document Before Adopting","text":"<p>Before adoption: 1. Export current Vault config 2. Document the resource's purpose 3. Identify who/what created it 4. Confirm no other automation manages it</p>"},{"location":"concepts/discovery/#4-test-adoption-in-non-production","title":"4. Test Adoption in Non-Production","text":"<ol> <li>Enable discovery in staging</li> <li>Adopt a resource</li> <li>Verify no disruption</li> <li>Then proceed to production</li> </ol>"},{"location":"concepts/discovery/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/discovery/#discovery-not-running","title":"Discovery Not Running","text":"<p>Symptoms: <code>lastScanAt</code> not updating</p> <p>Check: 1. <code>discovery.enabled</code> is <code>true</code> 2. VaultConnection is in <code>Active</code> phase 3. Operator has permission to list policies/roles</p>"},{"location":"concepts/discovery/#missing-expected-resources","title":"Missing Expected Resources","text":"<p>Symptoms: Known resources not appearing in discovery</p> <p>Check: 1. Pattern filters aren't excluding them 2. <code>excludeSystemPolicies</code> isn't filtering them 3. Resources aren't already managed by a CR</p>"},{"location":"concepts/discovery/#permission-denied-on-scan","title":"\"Permission Denied\" on Scan","text":"<p>Symptoms: Discovery fails with permission error</p> <p>Required Vault permissions: <pre><code># For policy discovery\npath \"sys/policies/acl\" {\n  capabilities = [\"list\"]\n}\n\n# For role discovery\npath \"auth/kubernetes/role\" {\n  capabilities = [\"list\"]\n}\n</code></pre></p>"},{"location":"concepts/discovery/#use-cases","title":"Use Cases","text":""},{"location":"concepts/discovery/#migration-from-cli-to-gitops","title":"Migration from CLI to GitOps","text":"<ol> <li>Enable discovery to audit existing resources</li> <li>Generate CRs for each discovered resource</li> <li>Add <code>adopt</code> annotation</li> <li>Apply via GitOps pipeline</li> <li>Disable direct CLI access</li> </ol>"},{"location":"concepts/discovery/#multi-cluster-vault","title":"Multi-Cluster Vault","text":"<p>When multiple clusters share Vault:</p> <pre><code># Cluster A\ndiscovery:\n  policyPatterns:\n    - \"cluster-a-*\"\n\n# Cluster B\ndiscovery:\n  policyPatterns:\n    - \"cluster-b-*\"\n</code></pre>"},{"location":"concepts/discovery/#compliance-audit","title":"Compliance Audit","text":"<p>Use discovery to regularly check for unmanaged resources:</p> <pre><code>discovery:\n  enabled: true\n  interval: 4h\n</code></pre> <p>Alert on <code>vault_access_operator_discovered_resources &gt; 0</code> to catch configuration drift.</p>"},{"location":"concepts/discovery/#see-also","title":"See Also","text":"<ul> <li>Drift Detection - Detect changes to managed resources</li> <li>Architecture - How discovery fits in the operator</li> <li>Getting Started - Initial setup guide</li> </ul>"},{"location":"concepts/drift-detection/","title":"Drift Detection","text":"<p>Drift detection identifies when Vault resources differ from their declared Kubernetes state. This is critical for maintaining configuration integrity and audit compliance.</p>"},{"location":"concepts/drift-detection/#what-is-drift","title":"What is Drift?","text":"<p>Drift occurs when the actual state of a Vault resource differs from the desired state declared in Kubernetes. This can happen due to:</p> <ul> <li>Manual changes via <code>vault</code> CLI or UI</li> <li>Automation scripts modifying Vault directly</li> <li>Other operators or tools managing the same resources</li> <li>Vault being restored from backup with stale data</li> </ul>"},{"location":"concepts/drift-detection/#drift-modes","title":"Drift Modes","text":"<p>The operator supports three drift modes, configurable per-resource or as a connection default:</p>"},{"location":"concepts/drift-detection/#ignore-mode","title":"<code>ignore</code> Mode","text":"<p>Behavior: Skip drift detection entirely.</p> <p>Use when: - Performance is critical and drift is unlikely - Resources are managed by multiple systems - You're migrating and want to avoid conflicts</p> <pre><code>spec:\n  driftMode: ignore\n</code></pre>"},{"location":"concepts/drift-detection/#detect-mode-default","title":"<code>detect</code> Mode (Default)","text":"<p>Behavior: Detect and report drift, but do NOT auto-correct.</p> <p>Use when: - You want visibility into unauthorized changes - Manual review is required before corrections - Compliance requires audit trails before changes</p> <pre><code>spec:\n  driftMode: detect\n</code></pre> <p>Status shows drift: <pre><code>status:\n  driftDetected: true\n  lastDriftCheckAt: \"2026-01-15T10:30:00Z\"\n  driftSummary: \"policy content differs\"\n</code></pre></p>"},{"location":"concepts/drift-detection/#correct-mode","title":"<code>correct</code> Mode","text":"<p>Behavior: Detect drift AND automatically overwrite Vault to match Kubernetes.</p> <p>Use when: - Kubernetes is the source of truth - GitOps requires automatic reconciliation - You want self-healing configuration</p> <pre><code>spec:\n  driftMode: correct\n</code></pre> <p>Status shows correction: <pre><code>status:\n  driftDetected: false\n  driftCorrectedAt: \"2026-01-15T10:30:00Z\"\n</code></pre></p>"},{"location":"concepts/drift-detection/#configuration","title":"Configuration","text":""},{"location":"concepts/drift-detection/#per-resource-configuration","title":"Per-Resource Configuration","text":"<p>Set drift mode on individual resources:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: critical-policy\nspec:\n  vaultConnectionRef:\n    name: vault-primary\n  driftMode: detect  # Override for this resource\n  rules:\n    - path: \"secret/data/critical/*\"\n      capabilities: [\"read\"]\n</code></pre>"},{"location":"concepts/drift-detection/#connection-defaults","title":"Connection Defaults","text":"<p>Set default drift mode for all resources using a connection:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nmetadata:\n  name: vault-primary\nspec:\n  address: https://vault.example.com:8200\n  auth:\n    kubernetes:\n      role: vault-access-operator\n  defaults:\n    driftMode: correct  # Default for all resources using this connection\n</code></pre>"},{"location":"concepts/drift-detection/#resolution-order","title":"Resolution Order","text":"<p>When determining drift mode:</p> <ol> <li>Resource-level <code>driftMode</code> takes precedence</li> <li>Connection-level <code>defaults.driftMode</code> used if resource doesn't specify</li> <li>System default <code>detect</code> used if neither specifies</li> </ol>"},{"location":"concepts/drift-detection/#status-fields","title":"Status Fields","text":""},{"location":"concepts/drift-detection/#drift-related-status","title":"Drift-Related Status","text":"Field Type Description <code>driftDetected</code> bool Whether drift exists <code>lastDriftCheckAt</code> time When drift was last checked <code>effectiveDriftMode</code> string Resolved drift mode <code>driftSummary</code> string Human-readable drift description <code>driftCorrectedAt</code> time When drift was last corrected"},{"location":"concepts/drift-detection/#example-status","title":"Example Status","text":"<pre><code>status:\n  phase: Active\n  driftDetected: true\n  effectiveDriftMode: detect\n  lastDriftCheckAt: \"2026-01-15T10:30:00Z\"\n  driftSummary: \"fields differ: policies, bound_service_account_names\"\n  conditions:\n    - type: Synced\n      status: \"True\"\n      reason: Succeeded\n    - type: DriftDetected\n      status: \"True\"\n      reason: DriftFound\n      message: \"Vault resource differs from desired state\"\n</code></pre>"},{"location":"concepts/drift-detection/#drift-detection-logic","title":"Drift Detection Logic","text":""},{"location":"concepts/drift-detection/#for-policies","title":"For Policies","text":"<p>Compares the HCL content:</p> <pre><code>Kubernetes VaultPolicy:              Vault Policy:\n  path \"secret/data/*\" {             path \"secret/data/*\" {\n    capabilities = [\"read\"]            capabilities = [\"read\", \"list\"]  \u2190 DRIFT\n  }                                  }\n</code></pre>"},{"location":"concepts/drift-detection/#for-roles","title":"For Roles","text":"<p>Compares key configuration fields:</p> Field Checked <code>policies</code> List of attached policies <code>bound_service_account_names</code> Bound service accounts <code>bound_service_account_namespaces</code> Bound namespaces <code>token_ttl</code> Token TTL <code>token_max_ttl</code> Max token TTL"},{"location":"concepts/drift-detection/#safety-controls","title":"Safety Controls","text":""},{"location":"concepts/drift-detection/#allow-destructive-annotation","title":"Allow Destructive Annotation","text":"<p>For <code>correct</code> mode, destructive changes require explicit opt-in:</p> <pre><code>apiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nmetadata:\n  name: existing-policy\n  annotations:\n    vault.platform.io/allow-destructive: \"true\"  # Required for correction\nspec:\n  driftMode: correct\n</code></pre> <p>Without this annotation, the operator will: 1. Detect drift 2. Log a warning 3. NOT overwrite the Vault resource 4. Set status to <code>Conflict</code></p>"},{"location":"concepts/drift-detection/#conflict-resolution","title":"Conflict Resolution","text":"<p>When a resource enters <code>Conflict</code> phase:</p> <ol> <li>Review the drift using <code>kubectl describe</code></li> <li>Decide on action:</li> <li>Add <code>allow-destructive</code> annotation to correct</li> <li>Update Kubernetes spec to match Vault</li> <li>Delete and recreate with <code>adopt</code> annotation</li> </ol>"},{"location":"concepts/drift-detection/#monitoring-drift","title":"Monitoring Drift","text":""},{"location":"concepts/drift-detection/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code># Drift detection gauge\nvault_access_operator_drift_detected{\n  resource=\"VaultPolicy\",\n  namespace=\"production\",\n  name=\"my-policy\"\n} 1\n\n# Drift correction counter\nvault_access_operator_drift_corrections_total{\n  resource=\"VaultPolicy\",\n  status=\"success\"\n}\n</code></pre>"},{"location":"concepts/drift-detection/#alerting-example","title":"Alerting Example","text":"<pre><code>groups:\n  - name: vault-access-operator\n    rules:\n      - alert: VaultDriftDetected\n        expr: vault_access_operator_drift_detected == 1\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Drift detected in {{ $labels.resource }}/{{ $labels.name }}\"\n</code></pre>"},{"location":"concepts/drift-detection/#kubernetes-events","title":"Kubernetes Events","text":"<p>The operator emits events for drift:</p> <pre><code>kubectl get events --field-selector reason=DriftDetected\n</code></pre>"},{"location":"concepts/drift-detection/#use-cases","title":"Use Cases","text":""},{"location":"concepts/drift-detection/#gitops-with-argocd","title":"GitOps with ArgoCD","text":"<pre><code># VaultConnection with correct mode for full GitOps\napiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nspec:\n  defaults:\n    driftMode: correct\n\n# Individual policy\nkind: VaultPolicy\nmetadata:\n  annotations:\n    vault.platform.io/allow-destructive: \"true\"\nspec:\n  # ...omit driftMode to inherit from connection\n</code></pre>"},{"location":"concepts/drift-detection/#audit-only-mode","title":"Audit-Only Mode","text":"<pre><code># Detect drift but require manual approval\napiVersion: vault.platform.io/v1alpha1\nkind: VaultConnection\nspec:\n  defaults:\n    driftMode: detect\n</code></pre> <p>Then review drift with: <pre><code>kubectl get vaultpolicies -o custom-columns=\\\nNAME:.metadata.name,\\\nDRIFT:.status.driftDetected,\\\nSUMMARY:.status.driftSummary\n</code></pre></p>"},{"location":"concepts/drift-detection/#high-performance-mode","title":"High-Performance Mode","text":"<pre><code># Skip drift checks for frequently updated resources\napiVersion: vault.platform.io/v1alpha1\nkind: VaultPolicy\nspec:\n  driftMode: ignore\n</code></pre>"},{"location":"concepts/drift-detection/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/drift-detection/#drift-never-detected","title":"Drift Never Detected","text":"<p>Symptoms: <code>driftDetected</code> always false despite manual changes</p> <p>Check: 1. Verify drift mode is not <code>ignore</code> 2. Confirm reconciliation is happening (check <code>lastSyncedAt</code>) 3. Check operator logs for errors</p>"},{"location":"concepts/drift-detection/#drift-corrections-failing","title":"Drift Corrections Failing","text":"<p>Symptoms: <code>driftCorrectedAt</code> not updating, status shows <code>Conflict</code></p> <p>Check: 1. Verify <code>allow-destructive</code> annotation is set 2. Check operator has write permissions to Vault 3. Review operator logs for specific errors</p>"},{"location":"concepts/drift-detection/#frequent-drift-detection","title":"Frequent Drift Detection","text":"<p>Symptoms: Drift constantly detected and corrected</p> <p>Possible causes: 1. Another system modifying the same resources 2. Race condition with multiple operators 3. Vault policy syntax normalization differences</p> <p>Solutions: 1. Identify and disable conflicting automation 2. Use <code>ignore</code> mode for contested resources 3. Ensure only one system manages each resource</p>"},{"location":"concepts/drift-detection/#see-also","title":"See Also","text":"<ul> <li>Architecture - How drift detection fits in reconciliation</li> <li>Discovery - Find unmanaged resources before adopting</li> <li>API Reference - Complete field reference</li> </ul>"}]}