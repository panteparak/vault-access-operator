name: CI

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

# Cancel in-progress runs on same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION_FILE: go.mod
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================================================
  # Setup: Platform Matrix
  # ============================================================================

  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.platforms.outputs.matrix }}
    steps:
      - name: Set platform matrix
        id: platforms
        run: |
          # Single source of truth for platforms
          echo 'matrix=["linux/amd64", "linux/arm64"]' >> $GITHUB_OUTPUT

  # ============================================================================
  # Stage 1: Parallel Jobs
  # ============================================================================

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-lint-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-lint-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-lint-
            ${{ runner.os }}-go-build-
      - uses: golangci/golangci-lint-action@v8
        with:
          version: v2.8.0
          args: --config=.golangci.yml
          # golangci-lint has its own cache - let it manage that
          skip-cache: false
      - name: Summary
        if: always()
        run: |
          echo "## ðŸ” Lint Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| golangci-lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY

  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-test-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-test-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-test-
            ${{ runner.os }}-go-build-
      - name: Run unit tests
        run: |
          set -o pipefail
          make test 2>&1 | tee test-output.txt
      - name: Generate coverage summary
        if: always()
        run: |
          echo "## ðŸ§ª Unit Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Coverage by Package" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Coverage |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
          grep -E "^ok|coverage:" test-output.txt | \
            sed 's/.*github.com\/panteparak\/vault-access-operator\///' | \
            awk '/^ok/ {pkg=$1} /coverage:/ {print "| " pkg " | " $2 " |"}' >> $GITHUB_STEP_SUMMARY || true
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f cover.out ]; then
            TOTAL=$(go tool cover -func=cover.out | grep total | awk '{print $3}')
            echo "**Total Coverage: ${TOTAL}**" >> $GITHUB_STEP_SUMMARY
          fi
      - uses: codecov/codecov-action@v4
        with:
          files: cover.out
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-integration-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-integration-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-integration-
            ${{ runner.os }}-go-build-
      - name: Run integration tests
        run: |
          # Integration tests require Docker for testcontainers
          # Generate JSON report for detailed test case summary
          # Use -count=1 to disable test caching (cached runs don't generate reports)
          go test ./test/integration/... -count=1 -v -ginkgo.v -ginkgo.show-node-events \
            -ginkgo.json-report=integration-report.json -timeout=10m 2>&1 | tee integration-output.txt || true

          # Ginkgo writes JSON reports to each test package directory
          # Combine all sub-package reports into one (handle missing gracefully)
          if find test/integration -name "integration-report.json" | grep -q .; then
            find test/integration -name "integration-report.json" -exec cat {} + | jq -s 'add' > integration-report.json 2>/dev/null || true
          fi
      - name: Generate integration test summary
        if: always()
        run: |
          echo "## ðŸ”Œ Integration Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate test case table from JSON report
          if [ -f integration-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            # Parse JSON and create table rows (skip skipped tests)
            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "âœ…" elif .State == "failed" then "âŒ" else "âš ï¸" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' integration-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            # Summary counts
            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' integration-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' integration-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' integration-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | âŒ Failed | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|-----------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show failure details if any
          if [ -f integration-output.txt ] && grep -q "FAIL" integration-output.txt; then
            echo "### âŒ Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" integration-output.txt >> $GITHUB_STEP_SUMMARY || tail -100 integration-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload integration test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-output
          path: |
            integration-output.txt
            integration-report.json
          retention-days: 7

  verify:
    name: Verify Generated Code & Manifests
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed to push auto-generated changes
    outputs:
      crds-updated: ${{ steps.check-changes.outputs.crds-updated }}
    steps:
      - uses: actions/checkout@v4
        with:
          # Need full history for push, and token with write access
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-verify-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-verify-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-verify-
            ${{ runner.os }}-go-build-
      - uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Generate code and manifests
        run: |
          make generate
          make manifests
          make helm-update-crds

      - name: Check for changes
        id: check-changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "::notice::Generated files have changes"
            git status --porcelain
          else
            echo "changes=false" >> $GITHUB_OUTPUT
          fi

          # Specifically check if CRDs changed
          if [ -n "$(git status --porcelain config/crd/bases/ charts/vault-access-operator/crds/)" ]; then
            echo "crds-updated=true" >> $GITHUB_OUTPUT
          else
            echo "crds-updated=false" >> $GITHUB_OUTPUT
          fi

      - name: Auto-commit generated changes
        if: steps.check-changes.outputs.changes == 'true' && github.event_name == 'push'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "chore: auto-generate manifests and CRDs

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          git push

      - name: Fail on PR with uncommitted changes
        if: steps.check-changes.outputs.changes == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated files are out of date. Run 'make generate manifests helm-update-crds' and commit."
          git diff
          exit 1

      - name: Upload CRDs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: generated-crds
          path: |
            config/crd/bases/
            charts/vault-access-operator/crds/
          retention-days: 1

      - name: Lint Helm chart
        run: |
          helm lint charts/vault-access-operator
          helm template test charts/vault-access-operator --set image.tag=test > /dev/null

      - name: Compare Kustomize and Helm templates
        id: template-compare
        run: |
          echo "## Template Comparison" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run comparison and capture output
          if make compare-templates 2>&1 | tee template-compare.txt; then
            echo "âœ… Templates are equivalent" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Template differences found (see details below)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand comparison output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat template-compare.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            # Don't fail the job - this is informational until templates are synced
            echo "::warning::Template differences found between kustomize and helm. Run 'make compare-templates' locally to see details."
          fi

      - name: Summary
        if: always()
        run: |
          echo "## âœ… Verification Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Generated code | ${{ steps.check-changes.outputs.changes == 'true' && 'ðŸ”„ Auto-committed' || 'âœ… Up-to-date' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| CRDs | ${{ steps.check-changes.outputs.crds-updated == 'true' && 'ðŸ”„ Updated' || 'âœ… Up-to-date' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Helm chart lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Template comparison | ${{ steps.template-compare.outcome == 'success' && 'âœ… Passed' || 'âš ï¸ Differences' }} |" >> $GITHUB_STEP_SUMMARY

  docker-build:
    name: Docker Build (${{ matrix.platform }})
    runs-on: ubuntu-latest
    needs: [setup]
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJson(needs.setup.outputs.platforms) }}
    outputs:
      image-tag: sha-${{ steps.short-sha.outputs.sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare platform vars
        id: platform
        run: |
          platform="${{ matrix.platform }}"
          echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT  # linux/amd64 -> linux-amd64

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Push events: Build and push platform-specific image
      - name: Build and push
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}
          cache-from: type=gha,scope=build-${{ steps.platform.outputs.pair }}
          cache-to: type=gha,scope=build-${{ steps.platform.outputs.pair }},mode=max

      # PRs: Build locally and save for e2e (amd64 only)
      - name: Build for PR
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: false
          load: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}
          cache-from: type=gha,scope=build-${{ steps.platform.outputs.pair }}
          cache-to: type=gha,scope=build-${{ steps.platform.outputs.pair }},mode=max

      - name: Save image for PR
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        run: |
          docker save ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }} \
            -o /tmp/operator-image.tar

      - uses: actions/upload-artifact@v4
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        with:
          name: operator-image
          path: /tmp/operator-image.tar
          retention-days: 1

  docker-manifest:
    name: Docker Manifest
    runs-on: ubuntu-latest
    needs: [setup, docker-build]
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push manifest
        run: |
          IMAGE_TAG="${{ needs.docker-build.outputs.image-tag }}"

          # Build list of platform-specific images
          IMAGES=""
          for platform in $(echo '${{ needs.setup.outputs.platforms }}' | jq -r '.[]'); do
            pair="${platform//\//-}"
            IMAGES="$IMAGES ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}-${pair}"
          done

          # Create manifest list with multiple tags
          docker buildx imagetools create \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            $IMAGES

      - name: Summary
        run: |
          echo "## ðŸ³ Docker Manifest" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Multi-platform manifest created:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | Platforms |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`${{ needs.docker-build.outputs.image-tag }}\` | ${{ needs.setup.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY
          echo "| \`latest\` | ${{ needs.setup.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY

  security-scan:
    name: Security Scan (${{ matrix.platform }})
    runs-on: ubuntu-latest
    needs: [setup, docker-build]
    permissions:
      contents: read
      packages: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJson(needs.setup.outputs.platforms) }}
    steps:
      - uses: actions/checkout@v4

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare platform vars
        id: platform
        run: |
          platform="${{ matrix.platform }}"
          echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT  # linux/amd64 -> linux-amd64

      # For PRs: Load the image from artifact (amd64 only)
      - uses: actions/download-artifact@v4
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        with:
          name: operator-image
          path: /tmp

      - name: Load image (PR)
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        run: docker load -i /tmp/operator-image.tar

      # For push events: Pull from registry
      - uses: docker/login-action@v3
        if: github.event_name != 'pull_request'
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image (push)
        if: github.event_name != 'pull_request'
        run: docker pull --platform ${{ matrix.platform }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}

      - name: Set image ref
        id: image
        run: |
          # Both PR and push use platform-specific tags for consistency
          echo "ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}" >> $GITHUB_OUTPUT

      # Skip non-amd64 scans for PRs (no image available)
      - name: Skip scan for non-amd64 PR
        if: github.event_name == 'pull_request' && matrix.platform != 'linux/amd64'
        run: |
          echo "Skipping security scan for ${{ matrix.platform }} on PR (only amd64 image available)"
          echo "## â­ï¸ Security Scan Skipped (${{ matrix.platform }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Non-amd64 scans are skipped for PRs (only amd64 image is built)." >> $GITHUB_STEP_SUMMARY

      # Generate SBOM (CycloneDX format)
      - name: Generate SBOM
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'image'
          image-ref: ${{ steps.image.outputs.ref }}
          format: 'cyclonedx'
          output: 'sbom.json'

      # Scan for all vulnerabilities (JSON output)
      - name: Scan for vulnerabilities (JSON - all)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'json'
          output: 'trivy-results.json'
          cache: 'false'

      # Scan for MEDIUM+ vulnerabilities, ignore unfixed (table for summary)
      - name: Scan for vulnerabilities (MEDIUM+, ignore unfixed)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'table'
          output: 'trivy-report.txt'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          cache: 'false'

      # Download HTML template and generate report
      - name: Download Trivy HTML template
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -o html.tpl

      - name: Generate HTML report
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'template'
          template: '@html.tpl'
          output: 'trivy-report.html'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          cache: 'false'

      # Generate SARIF for GitHub Security tab
      - name: Generate SARIF report
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'sarif'
          output: 'trivy-results.sarif'
          cache: 'false'

      - name: Upload SARIF to GitHub Security
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-container-scan-${{ steps.platform.outputs.pair }}'

      - name: Upload SBOM
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.platform.outputs.pair }}
          path: sbom.json
          retention-days: 30

      - name: Upload vulnerability report (JSON)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-json-${{ steps.platform.outputs.pair }}
          path: trivy-results.json
          retention-days: 30

      - name: Upload vulnerability report (HTML)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-html-${{ steps.platform.outputs.pair }}
          path: trivy-report.html
          retention-days: 30

      - name: Summary
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        run: |
          echo "## ðŸ”’ Security Scan Results (${{ matrix.platform }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Artifact | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`sbom-${{ steps.platform.outputs.pair }}.json\` | Software Bill of Materials (CycloneDX) |" >> $GITHUB_STEP_SUMMARY
          echo "| \`trivy-results-json-${{ steps.platform.outputs.pair }}.json\` | All vulnerabilities (JSON) |" >> $GITHUB_STEP_SUMMARY
          echo "| \`trivy-report-html-${{ steps.platform.outputs.pair }}.html\` | MEDIUM+ fixable vulnerabilities (HTML) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Vulnerability Counts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
          HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
          MEDIUM=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' trivy-results.json 2>/dev/null || echo "0")
          LOW=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="LOW")] | length' trivy-results.json 2>/dev/null || echo "0")
          echo "| ðŸ”´ Critical | ${CRITICAL} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | ${HIGH} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Medium | ${MEDIUM} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | ${LOW} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Detailed Report (MEDIUM+, fixable only)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>Click to expand</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat trivy-report.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Stage 2: Gate
  # ============================================================================

  gate:
    name: Gate
    runs-on: ubuntu-latest
    needs: [lint, unit-test, integration-test, verify, docker-build, docker-manifest]
    if: always()
    steps:
      - name: Check results
        run: |
          echo "Results: lint=${{ needs.lint.result }} unit=${{ needs.unit-test.result }} integration=${{ needs.integration-test.result }} verify=${{ needs.verify.result }} docker=${{ needs.docker-build.result }} manifest=${{ needs.docker-manifest.result }}"
          if [[ "${{ needs.lint.result }}" != "success" ]] || \
             [[ "${{ needs.unit-test.result }}" != "success" ]] || \
             [[ "${{ needs.verify.result }}" != "success" ]] || \
             [[ "${{ needs.docker-build.result }}" != "success" ]]; then
            echo "::error::One or more required jobs failed"
            exit 1
          fi
          # Integration tests are allowed to fail (may need Docker which isn't always available)
          if [[ "${{ needs.integration-test.result }}" != "success" ]] && \
             [[ "${{ needs.integration-test.result }}" != "skipped" ]]; then
            echo "::warning::Integration tests did not pass (may need Docker)"
          fi
          # docker-manifest is skipped for PRs, so check it only if it ran
          if [[ "${{ needs.docker-manifest.result }}" != "success" ]] && \
             [[ "${{ needs.docker-manifest.result }}" != "skipped" ]]; then
            echo "::error::docker-manifest job failed"
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          echo "## ðŸš¦ CI Gate Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Lint | ${{ needs.lint.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-test.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.integration-test.result == 'success' && 'âœ… Passed' || (needs.integration-test.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Verify | ${{ needs.verify.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Build | ${{ needs.docker-build.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.docker-manifest.result }}" != "skipped" ]]; then
            echo "| Docker Manifest | ${{ needs.docker-manifest.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # Stage 3: Security & Integration Tests
  # ============================================================================

  security-test:
    name: Security Integration Tests
    runs-on: ubuntu-latest
    needs: [gate]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-security-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-security-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-security-
            ${{ runner.os }}-go-build-
      - name: Run security tests
        run: |
          # Generate JSON report for detailed test case summary
          # Use -count=1 to disable test caching (cached runs don't generate reports)
          go test ./test/integration/security/... -count=1 -v -ginkgo.v -ginkgo.show-node-events \
            -ginkgo.json-report=security-report.json -timeout=10m 2>&1 | tee security-output.txt || true

          # Ginkgo writes JSON reports to test package directory
          # Copy to working directory for summary step (handle missing gracefully)
          if [ -f test/integration/security/security-report.json ]; then
            cp test/integration/security/security-report.json security-report.json
          fi
      - name: Generate security test summary
        if: always()
        run: |
          echo "## ðŸ”’ Security Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Categories" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Category | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-IV | Input Validation (injection, traversal) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-RB | RBAC Boundary (namespace isolation) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-TLS | TLS/mTLS (certificate handling) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-TK | Token Security (lifecycle, revocation) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-SH | Secret Handling (no secrets in logs) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-PE | Privilege Escalation prevention |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate test case table from JSON report
          if [ -f security-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            # Parse JSON and create table rows (skip skipped tests)
            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "âœ…" elif .State == "failed" then "âŒ" else "âš ï¸" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' security-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            # Summary counts
            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' security-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' security-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' security-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | âŒ Failed | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|-----------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show failure details if any
          if [ -f security-output.txt ] && grep -q "FAIL" security-output.txt; then
            echo "### âŒ Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" security-output.txt >> $GITHUB_STEP_SUMMARY || tail -150 security-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload security test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-test-output
          path: |
            security-output.txt
            security-report.json
          retention-days: 7

  integration-profiled:
    name: Integration Tests (Profiled)
    runs-on: ubuntu-latest
    needs: [gate]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-profiled-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-profiled-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-profiled-
            ${{ runner.os }}-go-build-
      - name: Run profiled integration tests
        run: |
          make test-integration-report 2>&1 | tee profiled-output.txt || true
      - name: Generate profiling summary
        if: always()
        run: |
          echo "## ðŸ“Š Integration Test Profiling" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Report Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Artifact | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`summary.html\` | Interactive HTML report with test metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| \`metrics.json\` | Machine-readable metrics for CI integration |" >> $GITHUB_STEP_SUMMARY
          echo "| \`*_flamegraph.svg\` | CPU/Memory flamegraphs per test |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f reports/profiling/metrics.json ]; then
            echo "### Suite Metrics" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            TOTAL=$(jq -r '.TotalTests // 0' reports/profiling/metrics.json)
            DURATION=$(jq -r '.Duration // 0' reports/profiling/metrics.json)
            PEAK_MEM=$(jq -r '.PeakMemory // 0' reports/profiling/metrics.json)
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Total Tests | ${TOTAL} |" >> $GITHUB_STEP_SUMMARY
            echo "| Duration | ${DURATION}ns |" >> $GITHUB_STEP_SUMMARY
            echo "| Peak Memory | ${PEAK_MEM} bytes |" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload profiling reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: profiling-reports
          path: reports/profiling/
          retention-days: 30

  # ============================================================================
  # Stage 4: E2E Tests
  # ============================================================================

  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [gate, verify]
    steps:
      - uses: actions/checkout@v4

      # Download generated CRDs from verify job to ensure we use latest
      - name: Download generated CRDs
        uses: actions/download-artifact@v4
        with:
          name: generated-crds
          path: /tmp/generated-crds

      - name: Copy CRDs to helm chart
        run: |
          echo "Copying generated CRDs to helm chart..."
          cp -v /tmp/generated-crds/charts/vault-access-operator/crds/*.yaml \
                ./charts/vault-access-operator/crds/ 2>/dev/null || \
          cp -v /tmp/generated-crds/config/crd/bases/*.yaml \
                ./charts/vault-access-operator/crds/
          echo "CRDs copied successfully"

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-e2e-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-e2e-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-e2e-
            ${{ runner.os }}-go-build-

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Set image tag
        id: image-tag
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "tag=sha-${{ steps.short-sha.outputs.sha }}-linux-amd64" >> $GITHUB_OUTPUT
          else
            echo "tag=sha-${{ steps.short-sha.outputs.sha }}" >> $GITHUB_OUTPUT
          fi

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      # --- E2E Infrastructure via Makefile targets (identical to local) ---

      - name: Start E2E infrastructure
        run: make e2e-compose-up

      - name: Wait for cluster
        run: make e2e-wait-cluster

      - name: Deploy and configure
        run: |
          make e2e-deploy-vault-rbac
          make e2e-bridge-vault
          make e2e-bridge-dex
          make e2e-configure-vault

      # PR: Load image from build artifact
      - uses: actions/download-artifact@v4
        if: github.event_name == 'pull_request'
        with:
          name: operator-image
          path: /tmp

      - name: Load operator image (PR)
        if: github.event_name == 'pull_request'
        run: |
          docker load -i /tmp/operator-image.tar
          make e2e-import-operator \
            E2E_OPERATOR_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}

      # Push: Pull image from GHCR, then import into k3s
      - name: Load operator image (push)
        if: github.event_name == 'push'
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
          make e2e-import-operator \
            E2E_OPERATOR_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}

      - name: Deploy operator
        run: |
          make e2e-deploy-operator \
            E2E_OPERATOR_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}

      - name: Verify deployment state
        env:
          KUBECONFIG: ${{ github.workspace }}/tmp/e2e/kubeconfig.yaml
        run: |
          echo "=== Operator Pod Status ==="
          kubectl get pods -n vault-access-operator-system -o wide

          echo ""
          echo "=== CRDs Installed ==="
          kubectl get crds | grep vault || echo "No Vault CRDs found!"

          echo ""
          echo "=== Vault Health (docker compose) ==="
          docker compose -f docker-compose.e2e.yaml exec -T vault vault status || echo "Vault not ready"

          echo ""
          echo "=== All Pods ==="
          kubectl get pods -A -o wide

      - name: Run E2E tests
        env:
          KUBECONFIG: ${{ github.workspace }}/tmp/e2e/kubeconfig.yaml
          VAULT_ADDR: http://localhost:8200
          E2E_K8S_HOST: https://k3s:6443
          E2E_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
          E2E_SKIP_BUILD: "true"
          E2E_SKIP_IMAGE_LOAD: "true"
        run: |
          set -o pipefail

          echo "=========================================="
          echo "Running E2E tests..."
          echo "=========================================="
          # Run all e2e tests in single invocation to share BeforeSuite/AfterSuite
          # (Running separate phases causes AfterSuite to tear down between phases)
          # Use -count=1 to disable test caching (cached runs don't generate reports)
          # Use -rapid.checks=10 to limit fuzz test iterations (default 100 is too slow for e2e)
          go test ./test/e2e/... -count=1 -v -ginkgo.v -ginkgo.fail-fast -ginkgo.show-node-events \
            -rapid.checks=10 -ginkgo.json-report=e2e-report.json -timeout=25m 2>&1 | tee e2e-output.txt

          # Ginkgo writes JSON reports to test package directory
          # Copy to working directory for summary step (handle missing gracefully)
          if [ -f test/e2e/e2e-report.json ]; then
            cp test/e2e/e2e-report.json e2e-report.json
          elif [ -f e2e-report.json ]; then
            echo "Report already in working directory"
          else
            echo "Warning: e2e-report.json not found, summary will be skipped"
          fi

      - name: E2E Summary
        if: always()
        run: |
          echo "## E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Install Method | Helm |" >> $GITHUB_STEP_SUMMARY
          echo "| Kubernetes | k3s (compose) |" >> $GITHUB_STEP_SUMMARY
          echo "| Vault | dev mode (compose, external) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f e2e-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "PASS" elif .State == "failed" then "FAIL" else "WARN" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' e2e-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' e2e-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' e2e-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' e2e-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Passed | Failed | Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|--------|---------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ -f e2e-output.txt ] && grep -q "FAIL" e2e-output.txt; then
            echo "### Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" e2e-output.txt >> $GITHUB_STEP_SUMMARY || tail -100 e2e-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Debug - E2E test output
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs
          echo "=== E2E Test Output ==="
          cat e2e-output.txt 2>/dev/null | tee /tmp/debug-logs/e2e-output.txt || true
          cp e2e-report.json /tmp/debug-logs/ 2>/dev/null || true

      - name: Debug - Vault logs
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/vault

          echo "=== Vault Container Logs ==="
          docker compose -f docker-compose.e2e.yaml logs vault 2>&1 | tee /tmp/debug-logs/vault/logs.txt || true

          echo ""
          echo "=== Vault Status ==="
          docker compose -f docker-compose.e2e.yaml exec -T vault vault status -format=json 2>&1 | tee /tmp/debug-logs/vault/status.json || true

          echo ""
          echo "=== Vault Auth Methods ==="
          docker compose -f docker-compose.e2e.yaml exec -T vault vault auth list -format=json 2>&1 | tee /tmp/debug-logs/vault/auth-list.json || true

      - name: Debug - Operator logs
        if: failure()
        env:
          KUBECONFIG: ${{ github.workspace }}/tmp/e2e/kubeconfig.yaml
        run: |
          mkdir -p /tmp/debug-logs/operator

          echo "=== Operator Pod Logs (last 1000 lines) ==="
          kubectl logs -n vault-access-operator-system -l control-plane=controller-manager --tail=1000 2>&1 | tee /tmp/debug-logs/operator/logs.txt || true

          echo ""
          echo "=== Operator Previous Logs (crash restarts) ==="
          kubectl logs -n vault-access-operator-system -l control-plane=controller-manager --previous --tail=500 2>&1 | tee /tmp/debug-logs/operator/logs-previous.txt || true

          echo ""
          echo "=== Operator Pod Describe ==="
          kubectl describe pods -n vault-access-operator-system 2>&1 | tee /tmp/debug-logs/operator/describe.txt || true

      - name: Debug - CRD status
        if: failure()
        env:
          KUBECONFIG: ${{ github.workspace }}/tmp/e2e/kubeconfig.yaml
        run: |
          mkdir -p /tmp/debug-logs/crds

          echo "=== VaultConnections ==="
          kubectl get vaultconnections -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultconnections.yaml || true

          echo ""
          echo "=== VaultPolicies ==="
          kubectl get vaultpolicies -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultpolicies.yaml || true

          echo ""
          echo "=== VaultClusterPolicies ==="
          kubectl get vaultclusterpolicies -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultclusterpolicies.yaml || true

          echo ""
          echo "=== VaultRoles ==="
          kubectl get vaultroles -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultroles.yaml || true

          echo ""
          echo "=== VaultClusterRoles ==="
          kubectl get vaultclusterroles -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultclusterroles.yaml || true

      - name: Debug - Cluster state
        if: failure()
        env:
          KUBECONFIG: ${{ github.workspace }}/tmp/e2e/kubeconfig.yaml
        run: |
          mkdir -p /tmp/debug-logs/cluster

          echo "=== All Pods ==="
          kubectl get pods -A -o wide 2>&1 | tee /tmp/debug-logs/cluster/pods.txt || true

          echo ""
          echo "=== All Events (sorted by time) ==="
          kubectl get events -A --sort-by='.lastTimestamp' 2>&1 | tee /tmp/debug-logs/cluster/all-events.txt || true

          echo ""
          echo "=== Nodes ==="
          kubectl describe nodes 2>&1 | tee /tmp/debug-logs/cluster/nodes.txt || true

          echo ""
          echo "=== Services ==="
          kubectl get svc -A -o wide 2>&1 | tee /tmp/debug-logs/cluster/services.txt || true

          echo ""
          echo "=== Endpoints ==="
          kubectl get endpoints -A 2>&1 | tee /tmp/debug-logs/cluster/endpoints.txt || true

      - name: Debug - Dex logs
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/dex

          echo "=== Dex Container Logs ==="
          docker compose -f docker-compose.e2e.yaml logs dex 2>&1 | tee /tmp/debug-logs/dex/logs.txt || true

          echo ""
          echo "=== Dex OIDC Discovery ==="
          curl -sf http://localhost:5556/.well-known/openid-configuration 2>&1 | tee /tmp/debug-logs/dex/discovery.json || true

      - name: Upload debug logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-debug-logs
          path: /tmp/debug-logs/
          retention-days: 7

      - name: Cleanup
        if: always()
        run: make e2e-compose-down

  # ============================================================================
  # Stage 5: Success
  # ============================================================================

  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [e2e, security-test, integration-profiled]
    if: always()
    steps:
      - name: Check all jobs
        run: |
          echo "E2E: ${{ needs.e2e.result }}"
          echo "Security: ${{ needs.security-test.result }}"
          echo "Profiled: ${{ needs.integration-profiled.result }}"

          # E2E is required
          if [[ "${{ needs.e2e.result }}" != "success" ]]; then
            echo "::error::E2E tests failed"
            exit 1
          fi

          # Security and profiled tests are informational
          if [[ "${{ needs.security-test.result }}" != "success" ]] && \
             [[ "${{ needs.security-test.result }}" != "skipped" ]]; then
            echo "::warning::Security tests did not pass"
          fi
          if [[ "${{ needs.integration-profiled.result }}" != "success" ]] && \
             [[ "${{ needs.integration-profiled.result }}" != "skipped" ]]; then
            echo "::warning::Profiled integration tests did not pass"
          fi

          echo "All CI checks passed!"

      - name: Final Summary
        if: always()
        run: |
          echo "## ðŸŽ‰ CI Pipeline Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 4 | E2E Tests | ${{ needs.e2e.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 3 | Security Tests | ${{ needs.security-test.result == 'success' && 'âœ… Passed' || (needs.security-test.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 3 | Profiled Tests | ${{ needs.integration-profiled.result == 'success' && 'âœ… Passed' || (needs.integration-profiled.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
