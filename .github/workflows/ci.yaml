name: CI

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
    branches: [main]

# Cancel in-progress runs on same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION_FILE: go.mod
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ============================================================================
  # Setup: Platform Matrix
  # ============================================================================

  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.platforms.outputs.matrix }}
    steps:
      - name: Set platform matrix
        id: platforms
        run: |
          # Single source of truth for platforms
          echo 'matrix=["linux/amd64", "linux/arm64"]' >> $GITHUB_OUTPUT

  # ============================================================================
  # Stage 1: Parallel Jobs
  # ============================================================================

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-lint-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-lint-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-lint-
            ${{ runner.os }}-go-build-
      - uses: golangci/golangci-lint-action@v8
        with:
          version: v2.8.0
          args: --config=.golangci.yml
          # golangci-lint has its own cache - let it manage that
          skip-cache: false
      - name: Summary
        if: always()
        run: |
          echo "## ðŸ” Lint Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| golangci-lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY

  unit-test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-test-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-test-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-test-
            ${{ runner.os }}-go-build-
      - name: Run unit tests
        run: |
          set -o pipefail
          make test 2>&1 | tee test-output.txt
      - name: Generate coverage summary
        if: always()
        run: |
          echo "## ðŸ§ª Unit Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Coverage by Package" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Package | Coverage |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|----------|" >> $GITHUB_STEP_SUMMARY
          grep -E "^ok|coverage:" test-output.txt | \
            sed 's/.*github.com\/panteparak\/vault-access-operator\///' | \
            awk '/^ok/ {pkg=$1} /coverage:/ {print "| " pkg " | " $2 " |"}' >> $GITHUB_STEP_SUMMARY || true
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f cover.out ]; then
            TOTAL=$(go tool cover -func=cover.out | grep total | awk '{print $3}')
            echo "**Total Coverage: ${TOTAL}**" >> $GITHUB_STEP_SUMMARY
          fi
      - uses: codecov/codecov-action@v4
        with:
          files: cover.out
          fail_ci_if_error: false
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-integration-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-integration-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-integration-
            ${{ runner.os }}-go-build-
      - name: Run integration tests
        run: |
          # Integration tests require Docker for testcontainers
          # Generate JSON report for detailed test case summary
          go test ./test/integration/... -v -ginkgo.v -ginkgo.show-node-events \
            -ginkgo.json-report=integration-report.json -timeout=10m 2>&1 | tee integration-output.txt || true
      - name: Generate integration test summary
        if: always()
        run: |
          echo "## ðŸ”Œ Integration Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate test case table from JSON report
          if [ -f integration-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            # Parse JSON and create table rows (skip skipped tests)
            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "âœ…" elif .State == "failed" then "âŒ" else "âš ï¸" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' integration-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            # Summary counts
            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' integration-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' integration-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' integration-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | âŒ Failed | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|-----------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show failure details if any
          if [ -f integration-output.txt ] && grep -q "FAIL" integration-output.txt; then
            echo "### âŒ Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" integration-output.txt >> $GITHUB_STEP_SUMMARY || tail -100 integration-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload integration test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-output
          path: |
            integration-output.txt
            integration-report.json
          retention-days: 7

  verify:
    name: Verify Generated Code & Manifests
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed to push auto-generated changes
    outputs:
      crds-updated: ${{ steps.check-changes.outputs.crds-updated }}
    steps:
      - uses: actions/checkout@v4
        with:
          # Need full history for push, and token with write access
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-verify-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-verify-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-verify-
            ${{ runner.os }}-go-build-
      - uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Generate code and manifests
        run: |
          make generate
          make manifests
          make helm-update-crds

      - name: Check for changes
        id: check-changes
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "::notice::Generated files have changes"
            git status --porcelain
          else
            echo "changes=false" >> $GITHUB_OUTPUT
          fi

          # Specifically check if CRDs changed
          if [ -n "$(git status --porcelain config/crd/bases/ charts/vault-access-operator/crds/)" ]; then
            echo "crds-updated=true" >> $GITHUB_OUTPUT
          else
            echo "crds-updated=false" >> $GITHUB_OUTPUT
          fi

      - name: Auto-commit generated changes
        if: steps.check-changes.outputs.changes == 'true' && github.event_name == 'push'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "chore: auto-generate manifests and CRDs

          Co-Authored-By: github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          git push

      - name: Fail on PR with uncommitted changes
        if: steps.check-changes.outputs.changes == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated files are out of date. Run 'make generate manifests helm-update-crds' and commit."
          git diff
          exit 1

      - name: Upload CRDs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: generated-crds
          path: |
            config/crd/bases/
            charts/vault-access-operator/crds/
          retention-days: 1

      - name: Lint Helm chart
        run: |
          helm lint charts/vault-access-operator
          helm template test charts/vault-access-operator --set image.tag=test > /dev/null

      - name: Compare Kustomize and Helm templates
        id: template-compare
        run: |
          echo "## Template Comparison" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run comparison and capture output
          if make compare-templates 2>&1 | tee template-compare.txt; then
            echo "âœ… Templates are equivalent" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Template differences found (see details below)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand comparison output</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            cat template-compare.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            # Don't fail the job - this is informational until templates are synced
            echo "::warning::Template differences found between kustomize and helm. Run 'make compare-templates' locally to see details."
          fi

      - name: Summary
        if: always()
        run: |
          echo "## âœ… Verification Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Generated code | ${{ steps.check-changes.outputs.changes == 'true' && 'ðŸ”„ Auto-committed' || 'âœ… Up-to-date' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| CRDs | ${{ steps.check-changes.outputs.crds-updated == 'true' && 'ðŸ”„ Updated' || 'âœ… Up-to-date' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Helm chart lint | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          echo "| Template comparison | ${{ steps.template-compare.outcome == 'success' && 'âœ… Passed' || 'âš ï¸ Differences' }} |" >> $GITHUB_STEP_SUMMARY

  docker-build:
    name: Docker Build (${{ matrix.platform }})
    runs-on: ubuntu-latest
    needs: [setup]
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJson(needs.setup.outputs.platforms) }}
    outputs:
      image-tag: sha-${{ steps.short-sha.outputs.sha }}
    steps:
      - uses: actions/checkout@v4

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare platform vars
        id: platform
        run: |
          platform="${{ matrix.platform }}"
          echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT  # linux/amd64 -> linux-amd64

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Push events: Build and push platform-specific image
      - name: Build and push
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}
          cache-from: type=gha,scope=build-${{ steps.platform.outputs.pair }}
          cache-to: type=gha,scope=build-${{ steps.platform.outputs.pair }},mode=max

      # PRs: Build locally and save for e2e (amd64 only)
      - name: Build for PR
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: false
          load: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}
          cache-from: type=gha,scope=build-${{ steps.platform.outputs.pair }}
          cache-to: type=gha,scope=build-${{ steps.platform.outputs.pair }},mode=max

      - name: Save image for PR
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        run: |
          docker save ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }} \
            -o /tmp/operator-image.tar

      - uses: actions/upload-artifact@v4
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        with:
          name: operator-image
          path: /tmp/operator-image.tar
          retention-days: 1

  docker-manifest:
    name: Docker Manifest
    runs-on: ubuntu-latest
    needs: [setup, docker-build]
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push manifest
        run: |
          IMAGE_TAG="${{ needs.docker-build.outputs.image-tag }}"

          # Build list of platform-specific images
          IMAGES=""
          for platform in $(echo '${{ needs.setup.outputs.platforms }}' | jq -r '.[]'); do
            pair="${platform//\//-}"
            IMAGES="$IMAGES ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}-${pair}"
          done

          # Create manifest list with multiple tags
          docker buildx imagetools create \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            $IMAGES

      - name: Summary
        run: |
          echo "## ðŸ³ Docker Manifest" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Multi-platform manifest created:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | Platforms |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`${{ needs.docker-build.outputs.image-tag }}\` | ${{ needs.setup.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY
          echo "| \`latest\` | ${{ needs.setup.outputs.platforms }} |" >> $GITHUB_STEP_SUMMARY

  security-scan:
    name: Security Scan (${{ matrix.platform }})
    runs-on: ubuntu-latest
    needs: [setup, docker-build]
    permissions:
      contents: read
      packages: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJson(needs.setup.outputs.platforms) }}
    steps:
      - uses: actions/checkout@v4

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Prepare platform vars
        id: platform
        run: |
          platform="${{ matrix.platform }}"
          echo "pair=${platform//\//-}" >> $GITHUB_OUTPUT  # linux/amd64 -> linux-amd64

      # For PRs: Load the image from artifact (amd64 only)
      - uses: actions/download-artifact@v4
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        with:
          name: operator-image
          path: /tmp

      - name: Load image (PR)
        if: github.event_name == 'pull_request' && matrix.platform == 'linux/amd64'
        run: docker load -i /tmp/operator-image.tar

      # For push events: Pull from registry
      - uses: docker/login-action@v3
        if: github.event_name != 'pull_request'
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image (push)
        if: github.event_name != 'pull_request'
        run: docker pull --platform ${{ matrix.platform }} ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}

      - name: Set image ref
        id: image
        run: |
          # Both PR and push use platform-specific tags for consistency
          echo "ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:sha-${{ steps.short-sha.outputs.sha }}-${{ steps.platform.outputs.pair }}" >> $GITHUB_OUTPUT

      # Skip non-amd64 scans for PRs (no image available)
      - name: Skip scan for non-amd64 PR
        if: github.event_name == 'pull_request' && matrix.platform != 'linux/amd64'
        run: |
          echo "Skipping security scan for ${{ matrix.platform }} on PR (only amd64 image available)"
          echo "## â­ï¸ Security Scan Skipped (${{ matrix.platform }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Non-amd64 scans are skipped for PRs (only amd64 image is built)." >> $GITHUB_STEP_SUMMARY

      # Generate SBOM (CycloneDX format)
      - name: Generate SBOM
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'image'
          image-ref: ${{ steps.image.outputs.ref }}
          format: 'cyclonedx'
          output: 'sbom.json'

      # Scan for all vulnerabilities (JSON output)
      - name: Scan for vulnerabilities (JSON - all)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'json'
          output: 'trivy-results.json'
          cache: 'false'

      # Scan for MEDIUM+ vulnerabilities, ignore unfixed (table for summary)
      - name: Scan for vulnerabilities (MEDIUM+, ignore unfixed)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'table'
          output: 'trivy-report.txt'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          cache: 'false'

      # Download HTML template and generate report
      - name: Download Trivy HTML template
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -o html.tpl

      - name: Generate HTML report
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'template'
          template: '@html.tpl'
          output: 'trivy-report.html'
          severity: 'MEDIUM,HIGH,CRITICAL'
          ignore-unfixed: true
          cache: 'false'

      # Generate SARIF for GitHub Security tab
      - name: Generate SARIF report
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'sbom'
          scan-ref: 'sbom.json'
          format: 'sarif'
          output: 'trivy-results.sarif'
          cache: 'false'

      - name: Upload SARIF to GitHub Security
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-container-scan-${{ steps.platform.outputs.pair }}'

      - name: Upload SBOM
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ steps.platform.outputs.pair }}
          path: sbom.json
          retention-days: 30

      - name: Upload vulnerability report (JSON)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-json-${{ steps.platform.outputs.pair }}
          path: trivy-results.json
          retention-days: 30

      - name: Upload vulnerability report (HTML)
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-html-${{ steps.platform.outputs.pair }}
          path: trivy-report.html
          retention-days: 30

      - name: Summary
        if: github.event_name != 'pull_request' || matrix.platform == 'linux/amd64'
        run: |
          echo "## ðŸ”’ Security Scan Results (${{ matrix.platform }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Artifact | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`sbom-${{ steps.platform.outputs.pair }}.json\` | Software Bill of Materials (CycloneDX) |" >> $GITHUB_STEP_SUMMARY
          echo "| \`trivy-results-json-${{ steps.platform.outputs.pair }}.json\` | All vulnerabilities (JSON) |" >> $GITHUB_STEP_SUMMARY
          echo "| \`trivy-report-html-${{ steps.platform.outputs.pair }}.html\` | MEDIUM+ fixable vulnerabilities (HTML) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Vulnerability Counts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Severity | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
          HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
          MEDIUM=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' trivy-results.json 2>/dev/null || echo "0")
          LOW=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="LOW")] | length' trivy-results.json 2>/dev/null || echo "0")
          echo "| ðŸ”´ Critical | ${CRITICAL} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | ${HIGH} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Medium | ${MEDIUM} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | ${LOW} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Detailed Report (MEDIUM+, fixable only)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>Click to expand</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat trivy-report.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Stage 2: Gate
  # ============================================================================

  gate:
    name: Gate
    runs-on: ubuntu-latest
    needs: [lint, unit-test, integration-test, verify, docker-build, docker-manifest]
    if: always()
    steps:
      - name: Check results
        run: |
          echo "Results: lint=${{ needs.lint.result }} unit=${{ needs.unit-test.result }} integration=${{ needs.integration-test.result }} verify=${{ needs.verify.result }} docker=${{ needs.docker-build.result }} manifest=${{ needs.docker-manifest.result }}"
          if [[ "${{ needs.lint.result }}" != "success" ]] || \
             [[ "${{ needs.unit-test.result }}" != "success" ]] || \
             [[ "${{ needs.verify.result }}" != "success" ]] || \
             [[ "${{ needs.docker-build.result }}" != "success" ]]; then
            echo "::error::One or more required jobs failed"
            exit 1
          fi
          # Integration tests are allowed to fail (may need Docker which isn't always available)
          if [[ "${{ needs.integration-test.result }}" != "success" ]] && \
             [[ "${{ needs.integration-test.result }}" != "skipped" ]]; then
            echo "::warning::Integration tests did not pass (may need Docker)"
          fi
          # docker-manifest is skipped for PRs, so check it only if it ran
          if [[ "${{ needs.docker-manifest.result }}" != "success" ]] && \
             [[ "${{ needs.docker-manifest.result }}" != "skipped" ]]; then
            echo "::error::docker-manifest job failed"
            exit 1
          fi

      - name: Summary
        if: always()
        run: |
          echo "## ðŸš¦ CI Gate Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Lint | ${{ needs.lint.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-test.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.integration-test.result == 'success' && 'âœ… Passed' || (needs.integration-test.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Verify | ${{ needs.verify.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Build | ${{ needs.docker-build.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.docker-manifest.result }}" != "skipped" ]]; then
            echo "| Docker Manifest | ${{ needs.docker-manifest.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================================================
  # Stage 3: Security & Integration Tests
  # ============================================================================

  security-test:
    name: Security Integration Tests
    runs-on: ubuntu-latest
    needs: [gate]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-security-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-security-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-security-
            ${{ runner.os }}-go-build-
      - name: Run security tests
        run: |
          # Generate JSON report for detailed test case summary
          go test ./test/integration/security/... -v -ginkgo.v -ginkgo.show-node-events \
            -ginkgo.json-report=security-report.json -timeout=10m 2>&1 | tee security-output.txt || true
      - name: Generate security test summary
        if: always()
        run: |
          echo "## ðŸ”’ Security Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Categories" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Category | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-IV | Input Validation (injection, traversal) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-RB | RBAC Boundary (namespace isolation) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-TLS | TLS/mTLS (certificate handling) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-TK | Token Security (lifecycle, revocation) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-SH | Secret Handling (no secrets in logs) |" >> $GITHUB_STEP_SUMMARY
          echo "| SEC-PE | Privilege Escalation prevention |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate test case table from JSON report
          if [ -f security-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            # Parse JSON and create table rows (skip skipped tests)
            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "âœ…" elif .State == "failed" then "âŒ" else "âš ï¸" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' security-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            # Summary counts
            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' security-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' security-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' security-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | âŒ Failed | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|-----------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show failure details if any
          if [ -f security-output.txt ] && grep -q "FAIL" security-output.txt; then
            echo "### âŒ Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" security-output.txt >> $GITHUB_STEP_SUMMARY || tail -150 security-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload security test output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-test-output
          path: |
            security-output.txt
            security-report.json
          retention-days: 7

  integration-profiled:
    name: Integration Tests (Profiled)
    runs-on: ubuntu-latest
    needs: [gate]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.GO_VERSION_FILE }}
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-profiled-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-profiled-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-profiled-
            ${{ runner.os }}-go-build-
      - name: Run profiled integration tests
        run: |
          make test-integration-report 2>&1 | tee profiled-output.txt || true
      - name: Generate profiling summary
        if: always()
        run: |
          echo "## ðŸ“Š Integration Test Profiling" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Report Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Artifact | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`summary.html\` | Interactive HTML report with test metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| \`metrics.json\` | Machine-readable metrics for CI integration |" >> $GITHUB_STEP_SUMMARY
          echo "| \`*_flamegraph.svg\` | CPU/Memory flamegraphs per test |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f reports/profiling/metrics.json ]; then
            echo "### Suite Metrics" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            TOTAL=$(jq -r '.TotalTests // 0' reports/profiling/metrics.json)
            DURATION=$(jq -r '.Duration // 0' reports/profiling/metrics.json)
            PEAK_MEM=$(jq -r '.PeakMemory // 0' reports/profiling/metrics.json)
            echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Total Tests | ${TOTAL} |" >> $GITHUB_STEP_SUMMARY
            echo "| Duration | ${DURATION}ns |" >> $GITHUB_STEP_SUMMARY
            echo "| Peak Memory | ${PEAK_MEM} bytes |" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload profiling reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: profiling-reports
          path: reports/profiling/
          retention-days: 30

  # ============================================================================
  # Stage 4: E2E Tests
  # ============================================================================

  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [gate, verify]
    steps:
      - uses: actions/checkout@v4

      # Download generated CRDs from verify job to ensure we use latest
      - name: Download generated CRDs
        uses: actions/download-artifact@v4
        with:
          name: generated-crds
          path: /tmp/generated-crds

      - name: Copy CRDs to helm chart
        run: |
          # Copy CRDs from artifact to helm chart (in case verify auto-committed new ones)
          echo "Copying generated CRDs to helm chart..."
          cp -v /tmp/generated-crds/charts/vault-access-operator/crds/*.yaml \
                ./charts/vault-access-operator/crds/ 2>/dev/null || \
          cp -v /tmp/generated-crds/config/crd/bases/*.yaml \
                ./charts/vault-access-operator/crds/
          echo "CRDs copied successfully"
          ls -la ./charts/vault-access-operator/crds/
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: false  # We use explicit caching below for better control
      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-mod-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-mod-
      - name: Cache Go build
        uses: actions/cache@v4
        with:
          path: ~/.cache/go-build
          key: ${{ runner.os }}-go-build-e2e-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/*.go') }}
          restore-keys: |
            ${{ runner.os }}-go-build-e2e-${{ hashFiles('**/go.sum') }}-
            ${{ runner.os }}-go-build-e2e-
            ${{ runner.os }}-go-build-

      - name: Get short SHA
        id: short-sha
        run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Set image tag
        id: image-tag
        run: |
          # E2E runs on amd64, so always use linux-amd64 platform tag
          # For PRs: use platform-specific tag (only amd64 is built)
          # For push: use manifest tag (works with multi-arch)
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "tag=sha-${{ steps.short-sha.outputs.sha }}-linux-amd64" >> $GITHUB_OUTPUT
          else
            echo "tag=sha-${{ steps.short-sha.outputs.sha }}" >> $GITHUB_OUTPUT
          fi

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup k3d with GHCR access
        run: |
          curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash

          # Create k3d registry config for GHCR authentication
          mkdir -p /tmp/k3d
          cat > /tmp/k3d/registries.yaml << EOF
          mirrors:
            "ghcr.io":
              endpoint:
                - "https://ghcr.io"
          configs:
            "ghcr.io":
              auth:
                username: ${{ github.actor }}
                password: ${{ secrets.GITHUB_TOKEN }}
          EOF

          k3d cluster create e2e --wait --timeout 120s \
            --registry-config /tmp/k3d/registries.yaml \
            --k3s-arg "--disable=traefik@server:*" \
            --k3s-arg "--disable=servicelb@server:*" \
            --k3s-arg "--disable=metrics-server@server:*" \
            --k3s-arg "--kube-apiserver-arg=service-account-issuer=https://kubernetes.default.svc@server:*"
          kubectl wait --for=condition=Ready nodes --all --timeout=60s

          # Wait for all kube-system pods (CoreDNS, local-path-provisioner, etc.)
          # Node readiness alone does NOT guarantee system pods are running.
          # Without CoreDNS, pods cannot resolve Service DNS names.
          kubectl wait --for=condition=Ready pods --all -n kube-system --timeout=120s

      - name: Deploy Dex OIDC Provider
        run: |
          docker run -d \
            --name dex \
            --network k3d-e2e \
            -p 5556:5556 \
            -v ${{ github.workspace }}/test/e2e/fixtures/dex-config.yaml:/etc/dex/config.yaml:ro \
            ghcr.io/dexidp/dex:v2.39.1 \
            dex serve /etc/dex/config.yaml

          echo "Waiting for Dex OIDC provider..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:5556/.well-known/openid-configuration > /dev/null 2>&1; then
              echo "Dex is ready"
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "ERROR: Dex failed to start"; docker logs dex; exit 1
            fi
            sleep 1
          done

          DEX_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' dex)
          echo "Dex IP: $DEX_IP"
          echo "DEX_IP=$DEX_IP" >> $GITHUB_ENV
          curl -s http://localhost:5556/.well-known/openid-configuration | jq .

      - name: Deploy Vault
        run: |
          kubectl apply -f test/e2e/fixtures/vault.yaml
          # Wait for StatefulSet rollout (handles pod creation timing)
          kubectl rollout status statefulset/vault -n vault --timeout=300s

      - name: Create Dex K8s Service
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Service
          metadata:
            name: dex
            namespace: default
          spec:
            ports:
              - port: 5556
                targetPort: 5556
          ---
          apiVersion: v1
          kind: Endpoints
          metadata:
            name: dex
            namespace: default
          subsets:
            - addresses:
                - ip: ${DEX_IP}
              ports:
                - port: 5556
          EOF

          echo "Verifying Dex from inside cluster..."
          for attempt in $(seq 1 5); do
            if kubectl run dex-test-${attempt} --rm -i --restart=Never \
              --image=curlimages/curl --timeout=30s -- \
              curl -sf --max-time 10 http://dex.default.svc.cluster.local:5556/.well-known/openid-configuration; then
              echo "Dex reachable from inside cluster"
              break
            fi
            if [ "$attempt" -eq 5 ]; then
              echo "ERROR: Dex not reachable from inside cluster after 5 attempts"
              kubectl get svc,endpoints dex -o wide
              kubectl get pods -n kube-system
              exit 1
            fi
            echo "Attempt ${attempt} failed, retrying in 3s..."
            sleep 3
          done

      - name: Configure Vault for E2E tests
        run: |
          # Create operator policy for E2E tests
          # Mirrors operatorPolicyHCL in e2e_suite_test.go â€” keep in sync
          # Note: -i flag is required to pass stdin (heredoc) to kubectl exec
          kubectl exec -i -n vault vault-0 -- vault policy write vault-access-operator - <<'EOF'
          # Policy management
          path "sys/policies/acl/*" { capabilities = ["create", "read", "update", "delete", "list"] }
          path "sys/policies/acl" { capabilities = ["list"] }
          # Kubernetes auth
          path "auth/kubernetes/role/*" { capabilities = ["create", "read", "update", "delete", "list"] }
          path "auth/kubernetes/role" { capabilities = ["list"] }
          path "auth/kubernetes/config" { capabilities = ["create", "read", "update", "delete"] }
          # JWT auth
          path "auth/jwt/role/*" { capabilities = ["create", "read", "update", "delete", "list"] }
          path "auth/jwt/role" { capabilities = ["list"] }
          path "auth/jwt/config" { capabilities = ["create", "read", "update", "delete"] }
          # AppRole auth
          path "auth/approle/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
          path "auth/approle" { capabilities = ["read"] }
          # OIDC (JWT at oidc path) auth
          path "auth/oidc/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
          path "auth/oidc" { capabilities = ["read"] }
          # Auth method management
          path "sys/auth" { capabilities = ["read"] }
          path "sys/auth/*" { capabilities = ["sudo", "create", "read", "update", "delete", "list"] }
          # Health + mounts
          path "sys/mounts" { capabilities = ["read"] }
          path "sys/health" { capabilities = ["read"] }
          # KV v2 managed resource metadata
          path "secret/data/vault-access-operator/managed/*" { capabilities = ["create", "read", "update", "delete"] }
          path "secret/metadata/vault-access-operator/managed/*" { capabilities = ["list", "read", "delete"] }
          EOF
          echo "Vault operator policy created successfully"

          # Enable auth methods for E2E tests
          kubectl exec -n vault vault-0 -- vault auth enable jwt || true
          echo "JWT auth method enabled"

          kubectl exec -n vault vault-0 -- vault auth enable approle || true
          echo "AppRole auth method enabled"

          kubectl exec -n vault vault-0 -- vault auth enable -path=oidc jwt || true
          echo "OIDC (JWT at oidc path) auth method enabled"

          # Get OIDC/JWKS configuration from the Kubernetes API
          OIDC_CONFIG=$(kubectl get --raw /.well-known/openid-configuration)
          ISSUER=$(echo "$OIDC_CONFIG" | jq -r '.issuer')
          echo "OIDC Issuer: $ISSUER"

          # Get the Kubernetes CA cert for TLS verification
          K8S_CA=$(kubectl get secret -n vault vault-token -o jsonpath='{.data.ca\.crt}' 2>/dev/null | base64 -d || \
                   kubectl exec -n vault vault-0 -- cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt)

          # Pre-fetch JWKS so it's available as fallback for both JWT and OIDC config
          JWKS=$(kubectl get --raw /openid/v1/jwks)

          # Configure JWT auth â€” try OIDC discovery first, fall back to JWKS
          if kubectl exec -i -n vault vault-0 -- vault write auth/jwt/config \
               oidc_discovery_url="$ISSUER" \
               bound_issuer="$ISSUER" \
               oidc_discovery_ca_pem="$K8S_CA" 2>/dev/null; then
            echo "JWT auth configured with OIDC discovery"
          else
            echo "OIDC discovery failed for JWT, falling back to JWKS"
            kubectl exec -n vault vault-0 -- vault write auth/jwt/config \
              jwt_validation_pubkeys="$JWKS" \
              bound_issuer="$ISSUER" || \
            echo "Warning: JWT auth configuration failed (tests will skip JWT auth)"
          fi

          # Configure OIDC (JWT at oidc path) auth with Dex OIDC discovery
          kubectl exec -n vault vault-0 -- vault write auth/oidc/config \
            oidc_discovery_url="http://dex.default.svc.cluster.local:5556" \
            bound_issuer="http://dex.default.svc.cluster.local:5556"
          echo "OIDC auth configured with Dex OIDC discovery"

      # For PRs: Load image from artifact (not in registry yet)
      - uses: actions/download-artifact@v4
        if: github.event_name == 'pull_request'
        with:
          name: operator-image
          path: /tmp

      - name: Load image into k3d (PR only)
        if: github.event_name == 'pull_request'
        run: |
          docker load -i /tmp/operator-image.tar
          k3d image import ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }} --cluster e2e

      # Deploy operator using Helm
      # Template comparison in verify job ensures kustomize and helm are equivalent
      - uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Deploy operator (Helm)
        run: |
          helm install vault-access-operator ./charts/vault-access-operator \
            --namespace vault-access-operator-system --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ steps.image-tag.outputs.tag }} \
            --set image.pullPolicy=IfNotPresent \
            --set webhook.enabled=false \
            --wait --timeout 5m

      - name: Wait for operator
        run: |
          kubectl wait --for=condition=Available deployment \
            -l app.kubernetes.io/name=vault-access-operator \
            -n vault-access-operator-system --timeout=120s

      - name: Verify deployment state
        run: |
          echo "=== Operator Pod Status ==="
          kubectl get pods -n vault-access-operator-system -o wide

          echo ""
          echo "=== CRDs Installed ==="
          kubectl get crds | grep vault || echo "No Vault CRDs found!"

          echo ""
          echo "=== Operator Logs (last 50 lines) ==="
          kubectl logs -n vault-access-operator-system \
            -l app.kubernetes.io/name=vault-access-operator \
            --tail=50 || echo "Could not get operator logs"

          echo ""
          echo "=== Vault Status ==="
          kubectl get pods -n vault -o wide
          kubectl exec -n vault vault-0 -- vault status || echo "Vault not ready or not unsealed"

      - name: Run E2E tests
        env:
          E2E_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
          E2E_SKIP_BUILD: "true"
          E2E_SKIP_IMAGE_LOAD: "true"
        run: |
          set -o pipefail

          # Run auth tests FIRST to catch authentication issues early
          echo "=========================================="
          echo "Phase 1: Running authentication tests..."
          echo "=========================================="
          go test ./test/e2e/... -v -ginkgo.v -ginkgo.fail-fast -ginkgo.show-node-events \
            -ginkgo.label-filter="auth" \
            -ginkgo.json-report=e2e-auth-report.json -timeout=10m 2>&1 | tee e2e-auth-output.txt

          # Run module/setup tests AFTER auth is verified
          echo "=========================================="
          echo "Phase 2: Running module tests..."
          echo "=========================================="
          go test ./test/e2e/... -v -ginkgo.v -ginkgo.fail-fast -ginkgo.show-node-events \
            -ginkgo.label-filter="module || setup" \
            -ginkgo.json-report=e2e-module-report.json -timeout=15m 2>&1 | tee e2e-module-output.txt

          # Combine outputs for summary
          cat e2e-auth-output.txt e2e-module-output.txt > e2e-output.txt
          jq -s 'add' e2e-auth-report.json e2e-module-report.json > e2e-report.json

      - name: E2E Summary
        if: always()
        run: |
          echo "## ðŸš€ E2E Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Install Method | Helm |" >> $GITHUB_STEP_SUMMARY
          echo "| Kubernetes | k3d |" >> $GITHUB_STEP_SUMMARY
          echo "| Vault | dev mode |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Generate test case table from JSON report
          if [ -f e2e-report.json ]; then
            echo "### Test Cases" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Status | Test Case | Duration |" >> $GITHUB_STEP_SUMMARY
            echo "|--------|-----------|----------|" >> $GITHUB_STEP_SUMMARY

            # Parse JSON and create table rows (skip skipped tests)
            jq -r '
              .[] | .SpecReports[]? |
              select(.State != "skipped" and .State != "") |
              (if .State == "passed" then "âœ…" elif .State == "failed" then "âŒ" else "âš ï¸" end) as $status |
              (.LeafNodeText // .ContainerHierarchyTexts[-1] // "Unknown") as $name |
              ((.RunTime / 1000000000 * 100 | floor) / 100) as $duration |
              "| \($status) | \($name) | \($duration)s |"
            ' e2e-report.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || true

            echo "" >> $GITHUB_STEP_SUMMARY

            # Summary counts
            PASSED=$(jq '[.[] | .SpecReports[]? | select(.State == "passed")] | length' e2e-report.json 2>/dev/null || echo "0")
            FAILED=$(jq '[.[] | .SpecReports[]? | select(.State == "failed")] | length' e2e-report.json 2>/dev/null || echo "0")
            SKIPPED=$(jq '[.[] | .SpecReports[]? | select(.State == "skipped")] | length' e2e-report.json 2>/dev/null || echo "0")

            echo "### Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| âœ… Passed | âŒ Failed | â­ï¸ Skipped |" >> $GITHUB_STEP_SUMMARY
            echo "|-----------|-----------|------------|" >> $GITHUB_STEP_SUMMARY
            echo "| ${PASSED} | ${FAILED} | ${SKIPPED} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Extract failures with context
          if [ -f e2e-output.txt ] && grep -q "FAIL" e2e-output.txt; then
            echo "### âŒ Failure Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Click to expand failure logs</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            grep -B 5 -A 30 "FAIL\!" e2e-output.txt >> $GITHUB_STEP_SUMMARY || tail -100 e2e-output.txt >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Debug - E2E test output
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs
          echo "=== E2E Test Output ==="
          cat e2e-output.txt 2>/dev/null | tee /tmp/debug-logs/e2e-output.txt || true
          cp e2e-report.json /tmp/debug-logs/ 2>/dev/null || true

      - name: Debug - Vault logs
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/vault

          echo "=== Vault Pod Logs (last 1000 lines) ==="
          kubectl logs vault-0 -n vault --tail=1000 2>&1 | tee /tmp/debug-logs/vault/logs.txt || true

          echo ""
          echo "=== Vault Pod Describe ==="
          kubectl describe pod vault-0 -n vault 2>&1 | tee /tmp/debug-logs/vault/describe.txt || true

          echo ""
          echo "=== Vault Namespace Events ==="
          kubectl get events -n vault --sort-by='.lastTimestamp' 2>&1 | tee /tmp/debug-logs/vault/events.txt || true

          echo ""
          echo "=== Vault Status ==="
          kubectl exec -n vault vault-0 -- vault status -format=json 2>&1 | tee /tmp/debug-logs/vault/status.json || true

          echo ""
          echo "=== Vault Auth Methods ==="
          kubectl exec -n vault vault-0 -- vault auth list -format=json 2>&1 | tee /tmp/debug-logs/vault/auth-list.json || true

      - name: Debug - Operator logs
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/operator

          echo "=== Operator Pod Logs (last 1000 lines) ==="
          kubectl logs -n vault-access-operator-system -l control-plane=controller-manager --tail=1000 2>&1 | tee /tmp/debug-logs/operator/logs.txt || true

          echo ""
          echo "=== Operator Previous Logs (crash restarts) ==="
          kubectl logs -n vault-access-operator-system -l control-plane=controller-manager --previous --tail=500 2>&1 | tee /tmp/debug-logs/operator/logs-previous.txt || true

          echo ""
          echo "=== Operator Pod Describe ==="
          kubectl describe pods -n vault-access-operator-system 2>&1 | tee /tmp/debug-logs/operator/describe.txt || true

          echo ""
          echo "=== Operator Namespace Events ==="
          kubectl get events -n vault-access-operator-system --sort-by='.lastTimestamp' 2>&1 | tee /tmp/debug-logs/operator/events.txt || true

      - name: Debug - CRD status
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/crds

          echo "=== VaultConnections ==="
          kubectl get vaultconnections -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultconnections.yaml || true

          echo ""
          echo "=== VaultPolicies ==="
          kubectl get vaultpolicies -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultpolicies.yaml || true

          echo ""
          echo "=== VaultClusterPolicies ==="
          kubectl get vaultclusterpolicies -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultclusterpolicies.yaml || true

          echo ""
          echo "=== VaultRoles ==="
          kubectl get vaultroles -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultroles.yaml || true

          echo ""
          echo "=== VaultClusterRoles ==="
          kubectl get vaultclusterroles -A -o yaml 2>&1 | tee /tmp/debug-logs/crds/vaultclusterroles.yaml || true

      - name: Debug - Cluster state
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/cluster

          echo "=== All Pods ==="
          kubectl get pods -A -o wide 2>&1 | tee /tmp/debug-logs/cluster/pods.txt || true

          echo ""
          echo "=== All Events (sorted by time) ==="
          kubectl get events -A --sort-by='.lastTimestamp' 2>&1 | tee /tmp/debug-logs/cluster/all-events.txt || true

          echo ""
          echo "=== Nodes ==="
          kubectl describe nodes 2>&1 | tee /tmp/debug-logs/cluster/nodes.txt || true

          echo ""
          echo "=== PVCs ==="
          kubectl get pvc -A -o wide 2>&1 | tee /tmp/debug-logs/cluster/pvcs.txt || true

          echo ""
          echo "=== Services ==="
          kubectl get svc -A -o wide 2>&1 | tee /tmp/debug-logs/cluster/services.txt || true

          echo ""
          echo "=== Endpoints ==="
          kubectl get endpoints -A 2>&1 | tee /tmp/debug-logs/cluster/endpoints.txt || true

      - name: Debug - Dex logs
        if: failure()
        run: |
          mkdir -p /tmp/debug-logs/dex

          echo "=== Dex Container Logs ==="
          docker logs dex 2>&1 | tee /tmp/debug-logs/dex/logs.txt || true

          echo ""
          echo "=== Dex Container Inspect ==="
          docker inspect dex 2>&1 | tee /tmp/debug-logs/dex/inspect.json || true

          echo ""
          echo "=== Dex OIDC Discovery ==="
          curl -sf http://localhost:5556/.well-known/openid-configuration 2>&1 | tee /tmp/debug-logs/dex/discovery.json || true

      - name: Upload debug logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-debug-logs
          path: /tmp/debug-logs/
          retention-days: 7

      - name: Cleanup Dex
        if: always()
        run: docker rm -f dex 2>/dev/null || true

      - name: Cleanup
        if: always()
        run: k3d cluster delete e2e || true

  # ============================================================================
  # Stage 5: Success
  # ============================================================================

  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [e2e, security-test, integration-profiled]
    if: always()
    steps:
      - name: Check all jobs
        run: |
          echo "E2E: ${{ needs.e2e.result }}"
          echo "Security: ${{ needs.security-test.result }}"
          echo "Profiled: ${{ needs.integration-profiled.result }}"

          # E2E is required
          if [[ "${{ needs.e2e.result }}" != "success" ]]; then
            echo "::error::E2E tests failed"
            exit 1
          fi

          # Security and profiled tests are informational
          if [[ "${{ needs.security-test.result }}" != "success" ]] && \
             [[ "${{ needs.security-test.result }}" != "skipped" ]]; then
            echo "::warning::Security tests did not pass"
          fi
          if [[ "${{ needs.integration-profiled.result }}" != "success" ]] && \
             [[ "${{ needs.integration-profiled.result }}" != "skipped" ]]; then
            echo "::warning::Profiled integration tests did not pass"
          fi

          echo "All CI checks passed!"

      - name: Final Summary
        if: always()
        run: |
          echo "## ðŸŽ‰ CI Pipeline Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 4 | E2E Tests | ${{ needs.e2e.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 3 | Security Tests | ${{ needs.security-test.result == 'success' && 'âœ… Passed' || (needs.security-test.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stage 3 | Profiled Tests | ${{ needs.integration-profiled.result == 'success' && 'âœ… Passed' || (needs.integration-profiled.result == 'skipped' && 'â­ï¸ Skipped' || 'âš ï¸ Warning') }} |" >> $GITHUB_STEP_SUMMARY
