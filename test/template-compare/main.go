/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package main provides a tool to compare kustomize and helm rendered templates.
// It parses both outputs, normalizes expected differences, and reports mismatches.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"reflect"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// Resource represents a parsed Kubernetes resource.
type Resource struct {
	obj        *unstructured.Unstructured
	apiVersion string
	kind       string
	name       string
	namespace  string
}

// Key returns a unique identifier for the resource.
func (r *Resource) Key() string {
	if r.namespace != "" {
		return fmt.Sprintf("%s/%s/%s", r.kind, r.namespace, r.name)
	}
	return fmt.Sprintf("%s/%s", r.kind, r.name)
}

// NormalizedKey returns a key using the normalized (helm-style) name.
func (r *Resource) NormalizedKey() string {
	normalizedName := r.name
	if mapped, ok := nameMapping[r.name]; ok {
		normalizedName = mapped
	}
	if r.namespace != "" {
		return fmt.Sprintf("%s/%s/%s", r.kind, r.namespace, normalizedName)
	}
	return fmt.Sprintf("%s/%s", r.kind, normalizedName)
}

// isKustomizeOnlyByName returns true if the resource name matches a kustomize-only pattern.
func isKustomizeOnlyByName(name string) bool {
	for _, pattern := range kustomizeOnlyNamePatterns {
		if strings.HasSuffix(name, pattern) {
			return true
		}
	}
	return false
}

// Difference represents a difference between two resources.
type Difference struct {
	Path      string
	Kustomize interface{}
	Helm      interface{}
}

// helmSpecificLabels are labels added by Helm that should be ignored.
var helmSpecificLabels = []string{
	"helm.sh/chart",
	"app.kubernetes.io/instance",
	"app.kubernetes.io/version",
	"app.kubernetes.io/part-of",
}

// helmOnlyResourceKinds are resource kinds that only Helm generates.
var helmOnlyResourceKinds = map[string]bool{
	"ValidatingWebhookConfiguration": true,
	"MutatingWebhookConfiguration":   true,
	"Certificate":                    true,
	"Issuer":                         true,
	"NetworkPolicy":                  true,
	"PodDisruptionBudget":            true,
	"ServiceMonitor":                 true,
}

// kustomizeOnlyResourceKinds are resource kinds that only Kustomize generates.
var kustomizeOnlyResourceKinds = map[string]bool{
	"Namespace":                true, // Kustomize creates namespace, Helm expects it to exist
	"CustomResourceDefinition": true, // CRDs are in Helm's crds/ directory, not in templates
}

// kustomizeOnlyNamePatterns are name patterns that only appear in kustomize output.
// These are typically RBAC helper roles generated by kubebuilder.
var kustomizeOnlyNamePatterns = []string{
	"-admin-role",
	"-editor-role",
	"-viewer-role",
}

// nameMapping maps kustomize resource names to helm resource names.
// This handles the naming convention differences between the two.
var nameMapping = map[string]string{
	// ServiceAccount
	"vault-access-operator-controller-manager": "vault-access-operator",
	// ClusterRoles
	"vault-access-operator-manager-role":      "vault-access-operator-manager",
	"vault-access-operator-metrics-auth-role": "vault-access-operator-metrics-auth",
	// ClusterRoleBindings
	"vault-access-operator-manager-rolebinding":      "vault-access-operator-manager",
	"vault-access-operator-metrics-auth-rolebinding": "vault-access-operator-metrics-auth",
	// Role
	"vault-access-operator-leader-election-role": "vault-access-operator-leader-election",
	// RoleBinding
	"vault-access-operator-leader-election-rolebinding": "vault-access-operator-leader-election",
	// Deployment
	// (same mapping as ServiceAccount)
	// Service
	"vault-access-operator-controller-manager-metrics-service": "vault-access-operator-metrics",
}

func main() {
	kustomizePath := flag.String("kustomize", "", "Path to kustomize rendered output")
	helmPath := flag.String("helm", "", "Path to helm rendered output")
	flag.Parse()

	if *kustomizePath == "" || *helmPath == "" {
		fmt.Fprintln(os.Stderr, "Both --kustomize and --helm paths are required")
		os.Exit(2)
	}

	kustomizeResources, err := parseYAMLFile(*kustomizePath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse kustomize output: %v\n", err)
		os.Exit(2)
	}

	helmResources, err := parseYAMLFile(*helmPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse helm output: %v\n", err)
		os.Exit(2)
	}

	exitCode := compare(kustomizeResources, helmResources)
	os.Exit(exitCode)
}

// parseYAMLFile reads a YAML file containing multiple documents and returns parsed resources.
func parseYAMLFile(path string) (map[string]*Resource, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("reading file: %w", err)
	}

	resources := make(map[string]*Resource)
	decoder := yaml.NewDecoder(bytes.NewReader(data))

	for {
		var doc map[string]interface{}
		err := decoder.Decode(&doc)
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("decoding YAML: %w", err)
		}
		if doc == nil {
			continue
		}

		// Convert int to int64 recursively (yaml.v3 uses int, k8s expects int64)
		convertInts(doc)

		obj := &unstructured.Unstructured{Object: doc}
		res := &Resource{
			obj:        obj,
			apiVersion: obj.GetAPIVersion(),
			kind:       obj.GetKind(),
			name:       obj.GetName(),
			namespace:  obj.GetNamespace(),
		}

		// Normalize the resource before storing
		normalizeResource(res.obj)

		resources[res.Key()] = res
	}

	return resources, nil
}

// convertInts recursively converts int values to int64 in a map.
// This is needed because yaml.v3 unmarshals numbers as int, but
// the Kubernetes unstructured library expects int64.
func convertInts(m map[string]interface{}) {
	for k, v := range m {
		switch val := v.(type) {
		case int:
			m[k] = int64(val)
		case map[string]interface{}:
			convertInts(val)
		case []interface{}:
			convertIntsSlice(val)
		}
	}
}

// convertIntsSlice recursively converts int values to int64 in a slice.
func convertIntsSlice(s []interface{}) {
	for i, v := range s {
		switch val := v.(type) {
		case int:
			s[i] = int64(val)
		case map[string]interface{}:
			convertInts(val)
		case []interface{}:
			convertIntsSlice(val)
		}
	}
}

// normalizeResource removes expected differences from a resource.
func normalizeResource(obj *unstructured.Unstructured) {
	// Normalize labels
	labels := obj.GetLabels()
	if labels != nil {
		for _, label := range helmSpecificLabels {
			delete(labels, label)
		}
		// Normalize managed-by label
		delete(labels, "app.kubernetes.io/managed-by")
		if len(labels) == 0 {
			obj.SetLabels(nil)
		} else {
			obj.SetLabels(labels)
		}
	}

	// Normalize annotations
	annotations := obj.GetAnnotations()
	if annotations != nil {
		// Remove helm-specific annotations
		delete(annotations, "meta.helm.sh/release-name")
		delete(annotations, "meta.helm.sh/release-namespace")
		if len(annotations) == 0 {
			obj.SetAnnotations(nil)
		} else {
			obj.SetAnnotations(annotations)
		}
	}

	// Remove status (if present)
	delete(obj.Object, "status")

	// For Deployments, normalize container resource defaults
	if obj.GetKind() == "Deployment" {
		normalizeDeployment(obj)
	}

	// For Services, normalize cluster IP and other generated fields
	if obj.GetKind() == "Service" {
		normalizeService(obj)
	}
}

// normalizeDeployment normalizes deployment-specific fields.
func normalizeDeployment(obj *unstructured.Unstructured) {
	// Normalize template labels
	templateLabels, found, _ := unstructured.NestedStringMap(obj.Object,
		"spec", "template", "metadata", "labels")
	if found {
		for _, label := range helmSpecificLabels {
			delete(templateLabels, label)
		}
		delete(templateLabels, "app.kubernetes.io/managed-by")
		if len(templateLabels) > 0 {
			_ = unstructured.SetNestedStringMap(obj.Object, templateLabels,
				"spec", "template", "metadata", "labels")
		}
	}

	// Remove selector matchLabels that are helm-specific
	selectorLabels, found, _ := unstructured.NestedStringMap(obj.Object,
		"spec", "selector", "matchLabels")
	if found {
		for _, label := range helmSpecificLabels {
			delete(selectorLabels, label)
		}
		delete(selectorLabels, "app.kubernetes.io/managed-by")
		if len(selectorLabels) > 0 {
			_ = unstructured.SetNestedStringMap(obj.Object, selectorLabels,
				"spec", "selector", "matchLabels")
		}
	}
}

// normalizeService normalizes service-specific fields.
func normalizeService(obj *unstructured.Unstructured) {
	// Normalize selector labels
	selectorLabels, found, _ := unstructured.NestedStringMap(obj.Object, "spec", "selector")
	if found {
		for _, label := range helmSpecificLabels {
			delete(selectorLabels, label)
		}
		delete(selectorLabels, "app.kubernetes.io/managed-by")
		if len(selectorLabels) > 0 {
			_ = unstructured.SetNestedStringMap(obj.Object, selectorLabels, "spec", "selector")
		}
	}
}

// compare compares kustomize and helm resources and returns exit code.
func compare(kustomize, helm map[string]*Resource) int {
	var (
		matched       []string
		kustomizeOnly []string
		helmOnly      []string
		differences   []string
		hasMismatch   bool
	)

	// Build a map of helm resources by normalized key for matching
	helmByNormalizedKey := make(map[string]*Resource)
	for _, hRes := range helm {
		helmByNormalizedKey[hRes.NormalizedKey()] = hRes
	}

	// Track which helm resources have been matched
	matchedHelmKeys := make(map[string]bool)

	// Find resources in both (using normalized keys for matching)
	for _, kRes := range kustomize {
		key := kRes.Key()
		normalizedKey := kRes.NormalizedKey()

		if helmRes, ok := helmByNormalizedKey[normalizedKey]; ok {
			matchedHelmKeys[helmRes.Key()] = true
			diffs := compareResources(kRes.obj, helmRes.obj)
			if len(diffs) > 0 {
				matched = append(matched, fmt.Sprintf("  ⚠️  %s (has differences)", key))
				for _, diff := range diffs {
					differences = append(differences, formatDifference(key, diff))
				}
				// Check if any difference is critical
				for _, diff := range diffs {
					if isCriticalDifference(diff) {
						hasMismatch = true
					}
				}
			} else {
				matched = append(matched, fmt.Sprintf("  ✅ %s", key))
			}
		} else {
			// Only in kustomize
			if kustomizeOnlyResourceKinds[kRes.kind] {
				kustomizeOnly = append(kustomizeOnly,
					fmt.Sprintf("  ℹ️  %s (expected: kustomize-only)", key))
			} else if isKustomizeOnlyByName(kRes.name) {
				kustomizeOnly = append(kustomizeOnly,
					fmt.Sprintf("  ℹ️  %s (expected: kubebuilder RBAC role)", key))
			} else {
				kustomizeOnly = append(kustomizeOnly,
					fmt.Sprintf("  ❌ %s (MISSING in helm)", key))
				hasMismatch = true
			}
		}
	}

	// Find resources only in helm
	for key, hRes := range helm {
		if matchedHelmKeys[key] {
			continue // Already matched
		}
		if helmOnlyResourceKinds[hRes.kind] {
			helmOnly = append(helmOnly,
				fmt.Sprintf("  ℹ️  %s (expected: helm-only)", key))
		} else {
			helmOnly = append(helmOnly,
				fmt.Sprintf("  ❌ %s (MISSING in kustomize)", key))
			hasMismatch = true
		}
	}

	// Sort for consistent output
	sort.Strings(matched)
	sort.Strings(kustomizeOnly)
	sort.Strings(helmOnly)

	// Print report
	fmt.Println("Resources in both:")
	if len(matched) == 0 {
		fmt.Println("  (none)")
	} else {
		for _, m := range matched {
			fmt.Println(m)
		}
	}

	fmt.Println()
	fmt.Println("Kustomize-only resources:")
	if len(kustomizeOnly) == 0 {
		fmt.Println("  (none)")
	} else {
		for _, k := range kustomizeOnly {
			fmt.Println(k)
		}
	}

	fmt.Println()
	fmt.Println("Helm-only resources:")
	if len(helmOnly) == 0 {
		fmt.Println("  (none)")
	} else {
		for _, h := range helmOnly {
			fmt.Println(h)
		}
	}

	var criticalDiffs, warningDiffs, infoDiffs []string
	for _, d := range differences {
		// Determine category based on the difference
		if strings.Contains(d, "(non-critical)") || strings.Contains(d, ".resources") {
			infoDiffs = append(infoDiffs, d)
		} else if strings.Contains(d, "missing in") {
			criticalDiffs = append(criticalDiffs, d)
		} else {
			warningDiffs = append(warningDiffs, d)
		}
	}

	if len(criticalDiffs) > 0 {
		fmt.Println()
		fmt.Println("Critical differences (MUST be fixed):")
		for _, d := range criticalDiffs {
			fmt.Println(d)
		}
	}

	if len(warningDiffs) > 0 {
		fmt.Println()
		fmt.Println("Warning differences (should review):")
		for _, d := range warningDiffs {
			fmt.Println(d)
		}
	}

	if len(infoDiffs) > 0 {
		fmt.Println()
		fmt.Println("Info differences (acceptable):")
		for _, d := range infoDiffs {
			fmt.Println(d)
		}
	}

	fmt.Println()
	if hasMismatch {
		fmt.Println("Result: ❌ MISMATCH (unexpected differences found)")
		fmt.Println("Please sync the kustomize and helm templates to fix the differences above.")
		return 1
	}
	fmt.Println("Result: ✅ PASS (templates are equivalent)")
	return 0
}

// compareResources compares two resources and returns differences.
func compareResources(kustomize, helm *unstructured.Unstructured) []Difference {
	var diffs []Difference

	// Compare specific fields based on resource type
	switch kustomize.GetKind() {
	case "Deployment":
		diffs = append(diffs, compareDeployments(kustomize, helm)...)
	case "ClusterRole", "Role":
		diffs = append(diffs, compareRBACRules(kustomize, helm)...)
	case "ClusterRoleBinding", "RoleBinding":
		diffs = append(diffs, compareRoleBindings(kustomize, helm)...)
	case "Service":
		diffs = append(diffs, compareServices(kustomize, helm)...)
	case "ServiceAccount":
		// ServiceAccounts are simple, just compare basic fields
		diffs = append(diffs, compareBasicFields(kustomize, helm)...)
	default:
		// For other types, do deep comparison
		diffs = append(diffs, compareDeep(kustomize.Object, helm.Object, "")...)
	}

	return diffs
}

// compareDeployments compares deployment-specific fields.
func compareDeployments(kustomize, helm *unstructured.Unstructured) []Difference {
	var diffs []Difference

	// Compare replicas
	kReplicas, _, _ := unstructured.NestedInt64(kustomize.Object, "spec", "replicas")
	hReplicas, _, _ := unstructured.NestedInt64(helm.Object, "spec", "replicas")
	if kReplicas != hReplicas {
		diffs = append(diffs, Difference{
			Path:      "spec.replicas",
			Kustomize: kReplicas,
			Helm:      hReplicas,
		})
	}

	// Compare containers
	kContainers, _, _ := unstructured.NestedSlice(kustomize.Object,
		"spec", "template", "spec", "containers")
	hContainers, _, _ := unstructured.NestedSlice(helm.Object,
		"spec", "template", "spec", "containers")

	if len(kContainers) != len(hContainers) {
		diffs = append(diffs, Difference{
			Path:      "spec.template.spec.containers.length",
			Kustomize: len(kContainers),
			Helm:      len(hContainers),
		})
	} else {
		for i := range kContainers {
			kc := kContainers[i].(map[string]interface{})
			hc := hContainers[i].(map[string]interface{})
			diffs = append(diffs, compareContainers(kc, hc, i)...)
		}
	}

	// Compare security context
	kSecCtx, kFound, _ := unstructured.NestedMap(kustomize.Object,
		"spec", "template", "spec", "securityContext")
	hSecCtx, hFound, _ := unstructured.NestedMap(helm.Object,
		"spec", "template", "spec", "securityContext")
	if kFound && hFound {
		diffs = append(diffs, compareDeep(kSecCtx, hSecCtx, "spec.template.spec.securityContext")...)
	}

	return diffs
}

// portNameMapping maps numeric ports to named ports.
var portNameMapping = map[int64]string{
	8081: "health",
	8443: "metrics",
}

// compareContainers compares container specs.
func compareContainers(kc, hc map[string]interface{}, idx int) []Difference {
	var diffs []Difference
	prefix := fmt.Sprintf("containers[%d]", idx)

	// Compare name
	if kc["name"] != hc["name"] {
		diffs = append(diffs, Difference{
			Path:      prefix + ".name",
			Kustomize: kc["name"],
			Helm:      hc["name"],
		})
	}

	// Skip image comparison - kustomize uses placeholder, helm uses values
	// This is expected and not a difference we need to report

	// Compare args (normalize by sorting and ignoring helm-specific additions)
	kArgs, _ := kc["args"].([]interface{})
	hArgs, _ := hc["args"].([]interface{})
	if !compareArgs(kArgs, hArgs) {
		// Only report if kustomize has args that helm doesn't have
		// Helm having additional args is fine (more secure defaults)
		missingInHelm := findMissingArgs(kArgs, hArgs)
		if len(missingInHelm) > 0 {
			diffs = append(diffs, Difference{
				Path:      prefix + ".args (missing in helm)",
				Kustomize: missingInHelm,
				Helm:      nil,
			})
		}
	}

	// Compare security context (helm having more is fine)
	kSecCtx, _ := kc["securityContext"].(map[string]interface{})
	hSecCtx, _ := hc["securityContext"].(map[string]interface{})
	if !isSubsetSecurityContext(kSecCtx, hSecCtx) {
		diffs = append(diffs, Difference{
			Path:      prefix + ".securityContext (non-critical)",
			Kustomize: kSecCtx,
			Helm:      hSecCtx,
		})
	}

	// Compare probes (normalize port number vs port name)
	for _, probe := range []string{"livenessProbe", "readinessProbe"} {
		kProbe, _ := kc[probe].(map[string]interface{})
		hProbe, _ := hc[probe].(map[string]interface{})
		if !compareProbes(kProbe, hProbe) {
			diffs = append(diffs, Difference{
				Path:      prefix + "." + probe,
				Kustomize: kProbe,
				Helm:      hProbe,
			})
		}
	}

	// Compare resources (warn only, not critical)
	kResources, _ := kc["resources"].(map[string]interface{})
	hResources, _ := hc["resources"].(map[string]interface{})
	if !reflect.DeepEqual(kResources, hResources) {
		diffs = append(diffs, Difference{
			Path:      prefix + ".resources (non-critical)",
			Kustomize: kResources,
			Helm:      hResources,
		})
	}

	return diffs
}

// compareArgs compares container args, allowing helm to have additional args.
func compareArgs(kArgs, hArgs []interface{}) bool {
	// Check that all kustomize args are present in helm args
	hArgSet := make(map[string]bool)
	for _, arg := range hArgs {
		if s, ok := arg.(string); ok {
			// Normalize arg by extracting the flag name
			hArgSet[normalizeArg(s)] = true
		}
	}

	for _, arg := range kArgs {
		if s, ok := arg.(string); ok {
			if !hArgSet[normalizeArg(s)] {
				return false
			}
		}
	}
	return true
}

// normalizeArg normalizes an argument by extracting just the flag name.
func normalizeArg(arg string) string {
	// Split on = to get just the flag name
	parts := strings.SplitN(arg, "=", 2)
	return parts[0]
}

// findMissingArgs finds args in kArgs that are not in hArgs.
func findMissingArgs(kArgs, hArgs []interface{}) []string {
	hArgSet := make(map[string]bool)
	for _, arg := range hArgs {
		if s, ok := arg.(string); ok {
			hArgSet[normalizeArg(s)] = true
		}
	}

	var missing []string
	for _, arg := range kArgs {
		if s, ok := arg.(string); ok {
			if !hArgSet[normalizeArg(s)] {
				missing = append(missing, s)
			}
		}
	}
	return missing
}

// isSubsetSecurityContext checks if kSecCtx settings are present in hSecCtx.
// Helm can have additional security settings (more secure is fine).
func isSubsetSecurityContext(kSecCtx, hSecCtx map[string]interface{}) bool {
	if kSecCtx == nil {
		return true
	}
	if hSecCtx == nil {
		return false
	}

	// Check that all kustomize security settings are in helm
	for k, kv := range kSecCtx {
		hv, ok := hSecCtx[k]
		if !ok {
			return false
		}
		if !reflect.DeepEqual(kv, hv) {
			return false
		}
	}
	return true
}

// compareProbes compares probes with port normalization.
func compareProbes(kProbe, hProbe map[string]interface{}) bool {
	if kProbe == nil && hProbe == nil {
		return true
	}
	if kProbe == nil || hProbe == nil {
		return false
	}

	// Compare non-httpGet fields directly
	for _, field := range []string{"initialDelaySeconds", "periodSeconds", "timeoutSeconds", "failureThreshold"} {
		if kProbe[field] != hProbe[field] {
			return false
		}
	}

	// Compare httpGet with port normalization
	kHTTP, _ := kProbe["httpGet"].(map[string]interface{})
	hHTTP, _ := hProbe["httpGet"].(map[string]interface{})
	if kHTTP == nil && hHTTP == nil {
		return true
	}
	if kHTTP == nil || hHTTP == nil {
		return false
	}

	// Compare path
	if kHTTP["path"] != hHTTP["path"] {
		return false
	}

	// Compare port (normalize numeric to named)
	kPort := kHTTP["port"]
	hPort := hHTTP["port"]
	return comparePortValues(kPort, hPort)
}

// comparePortValues compares port values, allowing numeric/named equivalents.
func comparePortValues(kPort, hPort interface{}) bool {
	// Direct equality
	if reflect.DeepEqual(kPort, hPort) {
		return true
	}

	// Try to normalize numeric port to named port
	if kPortInt, ok := kPort.(int64); ok {
		if portName, ok := portNameMapping[kPortInt]; ok {
			if hPortStr, ok := hPort.(string); ok && hPortStr == portName {
				return true
			}
		}
	}

	return false
}

// compareRBACRules compares RBAC rules by content, not order.
func compareRBACRules(kustomize, helm *unstructured.Unstructured) []Difference {
	var diffs []Difference

	kRules, _, _ := unstructured.NestedSlice(kustomize.Object, "rules")
	hRules, _, _ := unstructured.NestedSlice(helm.Object, "rules")

	// Normalize and compare rules by content
	kNorm := normalizeRBACRules(kRules)
	hNorm := normalizeRBACRules(hRules)

	if !reflect.DeepEqual(kNorm, hNorm) {
		// Find specific differences
		missingInHelm := findMissingRules(kNorm, hNorm)
		missingInKustomize := findMissingRules(hNorm, kNorm)

		if len(missingInHelm) > 0 {
			diffs = append(diffs, Difference{
				Path:      "rules (missing in helm)",
				Kustomize: missingInHelm,
				Helm:      nil,
			})
		}
		if len(missingInKustomize) > 0 {
			diffs = append(diffs, Difference{
				Path:      "rules (missing in kustomize)",
				Kustomize: nil,
				Helm:      missingInKustomize,
			})
		}
	}

	return diffs
}

// normalizeRBACRules normalizes RBAC rules for comparison by sorting.
func normalizeRBACRules(rules []interface{}) []string {
	normalized := make([]string, 0, len(rules))
	for _, rule := range rules {
		ruleMap, _ := rule.(map[string]interface{})
		normalized = append(normalized, formatRule(ruleMap))
	}
	sort.Strings(normalized)
	return normalized
}

// formatRule formats a single RBAC rule as a string for comparison.
func formatRule(rule map[string]interface{}) string {
	apiGroups := formatSlice(rule["apiGroups"])
	resources := formatSlice(rule["resources"])
	verbs := formatSlice(rule["verbs"])
	return fmt.Sprintf("apiGroups=%s,resources=%s,verbs=%s", apiGroups, resources, verbs)
}

// formatSlice formats a slice as a sorted comma-separated string.
func formatSlice(v interface{}) string {
	slice, _ := v.([]interface{})
	var strs []string
	for _, item := range slice {
		if s, ok := item.(string); ok {
			strs = append(strs, s)
		}
	}
	sort.Strings(strs)
	return strings.Join(strs, ",")
}

// findMissingRules finds rules in a that are not in b.
func findMissingRules(a, b []string) []string {
	bSet := make(map[string]bool)
	for _, rule := range b {
		bSet[rule] = true
	}

	var missing []string
	for _, rule := range a {
		if !bSet[rule] {
			missing = append(missing, rule)
		}
	}
	return missing
}

// compareRoleBindings compares role binding fields.
func compareRoleBindings(kustomize, helm *unstructured.Unstructured) []Difference {
	var diffs []Difference

	// Compare roleRef (normalize names)
	kRoleRef, _, _ := unstructured.NestedMap(kustomize.Object, "roleRef")
	hRoleRef, _, _ := unstructured.NestedMap(helm.Object, "roleRef")
	if !compareRoleRefs(kRoleRef, hRoleRef) {
		diffs = append(diffs, Difference{
			Path:      "roleRef",
			Kustomize: kRoleRef,
			Helm:      hRoleRef,
		})
	}

	// Compare subjects (normalize names)
	kSubjects, _, _ := unstructured.NestedSlice(kustomize.Object, "subjects")
	hSubjects, _, _ := unstructured.NestedSlice(helm.Object, "subjects")
	if !compareSubjects(kSubjects, hSubjects) {
		diffs = append(diffs, Difference{
			Path:      "subjects",
			Kustomize: kSubjects,
			Helm:      hSubjects,
		})
	}

	return diffs
}

// compareRoleRefs compares roleRef with name normalization.
func compareRoleRefs(kRoleRef, hRoleRef map[string]interface{}) bool {
	if kRoleRef == nil && hRoleRef == nil {
		return true
	}
	if kRoleRef == nil || hRoleRef == nil {
		return false
	}

	// Compare kind and apiGroup directly
	if kRoleRef["kind"] != hRoleRef["kind"] {
		return false
	}
	if kRoleRef["apiGroup"] != hRoleRef["apiGroup"] {
		return false
	}

	// Normalize names before comparing
	kName, _ := kRoleRef["name"].(string)
	hName, _ := hRoleRef["name"].(string)
	if mapped, ok := nameMapping[kName]; ok {
		kName = mapped
	}
	return kName == hName
}

// compareSubjects compares subjects with name normalization.
func compareSubjects(kSubjects, hSubjects []interface{}) bool {
	if len(kSubjects) != len(hSubjects) {
		return false
	}
	for i := range kSubjects {
		kSubj, _ := kSubjects[i].(map[string]interface{})
		hSubj, _ := hSubjects[i].(map[string]interface{})

		if kSubj["kind"] != hSubj["kind"] {
			return false
		}
		if kSubj["namespace"] != hSubj["namespace"] {
			return false
		}

		// Normalize names before comparing
		kName, _ := kSubj["name"].(string)
		hName, _ := hSubj["name"].(string)
		if mapped, ok := nameMapping[kName]; ok {
			kName = mapped
		}
		if kName != hName {
			return false
		}
	}
	return true
}

// compareServices compares service fields.
func compareServices(kustomize, helm *unstructured.Unstructured) []Difference {
	var diffs []Difference

	// Compare ports (normalize targetPort)
	kPorts, _, _ := unstructured.NestedSlice(kustomize.Object, "spec", "ports")
	hPorts, _, _ := unstructured.NestedSlice(helm.Object, "spec", "ports")
	if !compareServicePorts(kPorts, hPorts) {
		diffs = append(diffs, Difference{
			Path:      "spec.ports",
			Kustomize: kPorts,
			Helm:      hPorts,
		})
	}

	// Compare type (empty is equivalent to ClusterIP)
	kType, _, _ := unstructured.NestedString(kustomize.Object, "spec", "type")
	hType, _, _ := unstructured.NestedString(helm.Object, "spec", "type")
	// Normalize empty type to ClusterIP for comparison
	if kType == "" {
		kType = "ClusterIP"
	}
	if hType == "" {
		hType = "ClusterIP"
	}
	if kType != hType {
		diffs = append(diffs, Difference{
			Path:      "spec.type",
			Kustomize: kType,
			Helm:      hType,
		})
	}

	return diffs
}

// compareServicePorts compares service ports with targetPort normalization.
func compareServicePorts(kPorts, hPorts []interface{}) bool {
	if len(kPorts) != len(hPorts) {
		return false
	}

	for i := range kPorts {
		kPort, _ := kPorts[i].(map[string]interface{})
		hPort, _ := hPorts[i].(map[string]interface{})

		// Compare name, port, protocol
		if kPort["name"] != hPort["name"] {
			return false
		}
		if kPort["port"] != hPort["port"] {
			return false
		}
		if kPort["protocol"] != hPort["protocol"] {
			return false
		}

		// Compare targetPort with normalization
		if !comparePortValues(kPort["targetPort"], hPort["targetPort"]) {
			return false
		}
	}
	return true
}

// compareBasicFields compares basic metadata fields.
func compareBasicFields(kustomize, helm *unstructured.Unstructured) []Difference {
	// For ServiceAccounts, we skip name comparison since names are mapped
	// Just verify they exist (already matched by normalized key)
	return nil
}

// compareDeep performs a deep comparison of two maps.
func compareDeep(k, h map[string]interface{}, path string) []Difference {
	var diffs []Difference

	// Skip known non-critical paths
	if strings.Contains(path, "resources") {
		return nil
	}

	if !reflect.DeepEqual(k, h) {
		diffs = append(diffs, Difference{
			Path:      path,
			Kustomize: k,
			Helm:      h,
		})
	}

	return diffs
}

// formatDifference formats a difference for display.
func formatDifference(key string, diff Difference) string {
	var buf bytes.Buffer
	w := bufio.NewWriter(&buf)

	fmt.Fprintf(w, "  %s -> %s:\n", key, diff.Path)
	fmt.Fprintf(w, "    kustomize: %v\n", formatValue(diff.Kustomize))
	fmt.Fprintf(w, "    helm:      %v\n", formatValue(diff.Helm))

	w.Flush()
	return buf.String()
}

// formatValue formats a value for display, truncating if too long.
func formatValue(v interface{}) string {
	s := fmt.Sprintf("%v", v)
	if len(s) > 100 {
		return s[:100] + "..."
	}
	return s
}

// isCriticalDifference returns true if the difference is critical.
func isCriticalDifference(diff Difference) bool {
	// Resource differences are not critical
	if strings.Contains(diff.Path, "resources") {
		return false
	}
	// Non-critical annotations
	if strings.Contains(diff.Path, "non-critical") {
		return false
	}
	// Security context enhancements in helm are not critical
	if strings.Contains(diff.Path, "securityContext") {
		return false
	}
	return true
}

// categorizeDifference returns "critical", "warning", or "info" for display.
